^title Methods and Initializers
^part A Bytecode Virtual Machine

> When you are on the dancefloor, there is nothing to do but dance.
>
> <cite>Umberto Eco, <em>The Mysterious Flame of Queen Loana</em></cite>

- bring objects to life adding behavior
- add methods and method calls
- initializers, special kind of method
- because part ii more perf focused, do very important opt

## Method Declarations

- before call, need to have methods
- similar to jlox -- hash table of methods in class obj
- runtime rep of method just ObjClosure same as fn decl

- compiler parses method decls in class body
- at runtime runtime rep of class has hash table of methods
- when exec class decl, populate with each declared method

- [no checking for duplicate methods
  would be good for real lang]

- going from syntax to runtime rep harder in clox because of bytecode
- in jlox, interpreter had ast node for entire class including all contained
  methods
- at runtime when interp class decl, walk list of methods

- for clox, no ast node
- need flattened bytecode rep for series of method decls
- as we'll see, pretty simple

### Compiling method declarations

- first start in front end
- from last chap compile has class decl but body empty
- now allow method decls

^code class-body (1 before, 1 after)

- until reach closing `}` everything inside must be method decl
- also need to check for eof
- if user forget to close class decl, avoid infinite loop in comp

- compile single method here

^code method

- very similar to fn definition and reuse same utility fn
- first compile method name
- store as string in constant table
- since runtime rep is hash table of method names to methods, need name at
  runtime, just like with fields
- then use `function()` to compile method body to clox fn
- leaves resulting fn obj on top of stack
- finally emit new `OP_METHOD` instr

^code method-op (1 before, 1 after)

- new instr creates new runtime rep of method
- how bytecode flattens out class decl into series of instrs
- turns declaration into series of imperative mutating ops
- first `OP_CLASS` creates new empty class
- then series of `OP_METHOD` binds new method to class
- instr needs to know
  - name of method
  - fun for method body
  - class to bind method to

- fun is on top of stack, gets from there
- inst has operand for index of method name in const table
- dis like other instrs that ref string const

^code disassemble-method (2 before, 1 after)

- finding class to bind method to harder
- may not be on top of stack
- if class declared at top level, then generated bytecode for class
  execs `OP_CLASS` then stores result in global var and pops
- [could do stack juggling to ensure on top of stack, but get harder with
  superclasses]

- compiler does know name of class
- and know that nothing between class decl and method decl can cause new name
  to shadow
- so before each `OP_METHOD`, emit bytecode to load class from named var back
  on to top of stack
- then `OP_METHOD` gets class and then method fun from stack

**todo: show stack**

- so when compile class, remember class name

^code class-name (1 before, 1 after)

- before each method decl, emit code to load class obj back onto stack

^code load-class (1 before, 2 after)

**todo: illustrate bytecode for series of method decls**

- seem inefficient to execute code to repeatedly load class obj onto stack for
  each method
- only when exec class decl which almost never anywhere near perf critical

### Storing methods at runtime

- over in vm, new instr

^code interpret-method (1 before, 1 after)

- reads method name from const table at operand index
- then call

^code define-method

- obj closure for method on top of stack
- class obj right under
- don't need any runtime checking for types since whole chunk of bytecode
  emitted by our compiler and know correct objects in stack slots
- [vm assumes only executed bytecode its own compiler just generated
  - jvm and cpython can exec bytecode loaded from disc or compiled separately
  - can't trust that bytecode is correct
  - jvm has bytecode verifier runs when loading code to ensure doesn't violate
    stack expectations
  - todo: cpython?]

- store given method obj in given class's method table then pop from stack
- class doesn't have method table
- do now

^code class-methods (1 before, 1 after)

- already have hash table ds so easy
- add to class struct
- when create new class obj, init empty

^code init-methods (1 before, 1 after)

- class owns table so when free class, deallocate table mem

^code free-methods (1 before, 1 after)

- gc needs to handle too
- when gc reaches class, class methods (and names) all reachable too

^code mark-methods (1 before, 1 after)

- can now compile and exec class with method decls
- next is using them

## Method References

- recall method call two ops
- [todo: example]
- user can separate so need to impl separately

- first dot syntax to access reference to method
- returns obj
- then runtime support for calling that obj

- start with access
- simple approach just return objclosure bound to method name
- remember when access method need to bind this
- [example]

- in jlox used env
- clox more complex rep with closure and stack
- new runtime rep -- bound method
- [name from cpython]

- wrap raw closure for method in struct that stores this binding
- when access prop, look up method wrap in bound
- [illustrate bound fn pointing to method closure]
- then when called, do thing to bind this
- [get to later]

### Bound methods

- new obj type
- boring, but last time need to do this
- final obj type for vm

^code obj-bound-method (2 before, 1 after)

- stores pointer to closure for method
- also stores value for receiver
- instance that method was accessed on
- will become avail in body of method using `this`
- [could type as ObjInstance since will always be, but vm doesn't really care
  what kind of value receiver is, so just used value]

- usual new obj type stuff
- type check macro

^code is-bound-method (2 before, 1 after)

- cast macro

^code as-bound-method (2 before, 1 after)

- obj type enum case

^code obj-type-bound-method (1 before, 1 after)

- declare fn to create new

^code new-bound-method-h (2 before, 1 after)

- impl

^code new-bound-method

- as usual, just stores given closure and receiver in struct

- doesn't own any memory, so freeing just free struct

^code free-bound-method (1 before, 1 after)

- doesn't own, but does refer to objs, to gc needs to trace through

^code blacken-bound-method (1 before, 1 after)

- ensures that reference to method keeps instance alive
- [and method, but method will already be reachable through receiver's class]

- last operation all objs support is print

^code print-bound-method (1 before, 1 after)

- prints exactly same as fn
- from user perspective ref to method just another function they can call
- don't expose to user that vm implements using different type

### Accessing methods

- now hook up to runtime
- methods accessed just like fields using `.` syntax
- need to determine at runtime whether property name refers to field or method
- fields take priority so if no field with that name, then look for method on
  receiver's class

^code get-method (5 before, 1 after)

- returns false if not found
- in that case, nothing bound to property name, and runtime error
- otherwise, did find method and stored on stack
- looks like

^code bind-method

- look for closure in class's method table with given prop name
- if not found, report runtime error
- otherwise, take closure and wrap in bound method obj binding receiver
- pop instance off stack and replace with bound method

**todo: illustrate**

### Calling methods

- once user has bound method obj, can call like fn
- means add obj type case to call

^code call-bound-method (1 before, 1 after)

- just extract closure and invoke
- can now run

**todo: show example user can run**

- but wait, what about receiver?
- whole point of bound method obj is to provide access to receiver?
- but call doesn't pass in
- before get to that, need syntax to access inside method body

## This

- in lox, way access receiver that method called on inside body of method is
  `this`
- used for accessing fields and calling methods
- if make `this` work everything works

- similar to jlox most reuse machinery for vars
- treat "this" as lexical scoped local var
- that way closures close over this work correctly

**todo: example**

- when parser sees keyword

^code table-this (1 before, 1 after)

- calls

^code this

- just compiles keyword lexeme like variable name

- this will fail since didn't define any var named this
- need to figure out where lives
- clox uses stack for locals
- already have special slot zero
- for fns stores fn being called has no name
- [mostly exists as placeholder to align with how caller organizes stack]
- for methods can use to store receiver instead

- when compile method instead of fn, give slot zero name

^code slot-zero (1 before, 1 after)

- when compiling body, compiler needs to know if fn or method
- new fn type enum case

^code method-type-enum (1 before, 1 after)

- when compile method set to new type

^code method-type (2 before, 1 after)

- [weird local var here because add another type soon]

- compiler now understand this in local slot zero
- correctly compile references to this

- runtime needs to make reality
- when invoke bound method, store receiver in slot

^code store-receiver (2 before, 2 after)

**todo: illustrate stack layout for function versus method call**

- methods feel like methods now -- act *on* obj

**todo: show example user can run**

### Misusing this

- vm can use this correctly
- also needs to prevent using incorrectly
- lox defines compile time error to use `this` when not inside body of method
  in class
- should be errors to use here

```lox
print this; // At top level.

fun notMethod() {
  print this; // In a function.
}
```

- compiler does not currently know if inside class
- add new module var to track information about current class body being
  compiled

^code current-class (1 before, 2 after)

- could just use int to keep track of number of surrounding class
- increment when class body begin, dec end
- if >0, in class and can use this

- but compiler soon need track other info about current class being compiled
- set up new type to track that

^code class-compiler-struct (1 before, 2 after)

- module var be null when not in middle of compiling class body
- right now, just store name
- since classes can nest, like compiler does for nested fn, works like linked
  list
- each classcom ref to enclosing class's compiler

- when begin comp class body, push new compiler

^code create-class-compiler (2 before, 1 after)

- store name to use later
- link to enclosing class if any
- otherwise null

- when reach end of body pop compiler

^code pop-enclosing (1 before, 1 after)

- now can use module var to tell if inside class or not

^code this-outside-class (1 before, 1 after)

- if null, no enclosing class so error to use this

## Instance Initializers

- methods can access state of containing instance
- starting to feel like obj
- one reason oop bundles state and behavior together is so class can ensure
  object always in valid state
- means need to be correctly initialized when first created
- initializer methods

- init mostly like regular method
- special in couple of ways
  - implicitly called by runtime when instance created
  - implicitly returns instance -- no return "this" needed
    - [can think of as runtime wraps call to init in own code that returns
      instance]
  - cannot return other value

- impl basically in that order
- when create instance, call init method

^code call-init (1 before, 1 after)

- after alloc instance, look for init method on class
- if found call it using existing helper
- that pushes call frame for init method closure and checks that arity of
  method matches number of args passed
- args passed to class call still on stack and get forwarded to init

- lox allows class to omit init method
- in that case, behave as before
- however, if no init method, doesn't make sense to pass args to class when
  creating instance
- add check

^code no-init-arity-error (2 before, 1 after)

- when no init method, runtime error to pass args
- when there is init method, `call()` handles checking arity

- init method looked up by name
- want to be fast since done every time class constructed
- [could cache ref to init method in class]
- to take advantage of string interning, want init string in ObjString
- so store one in vm

^code vm-init-string (1 before, 1 after)

- populate when vm start up

^code init-init-string (1 before, 2 after)

- treat as root to keep alive during gc

^code mark-init-string (1 before, 1 after)

- and free when shutting down

^code clear-init-string (1 before, 1 after)

- vm now calls init method
- can correctly initialize new instance

### Initializer return values

- next is ensure init returns new instance
- right now, treated like normal fn and returns whatever fn returns
- to fix, when compiler is compiling init method, emit different bytecode to
  return `this` at end of fn body instead of implicit `nil` all functions
  return
- to do that, compiler needs to know when compiling init
- init must be a method inside class and must be named `init()`
- so when compiling method check name

^code initializer-name (1 before, 1 after)

- if name is init, use new fn type

^code initializer-type-enum (1 before, 1 after)

- then when emitting code for implicit return at end of body, return this
  if in init

^code return-this (1 before, 1 after)

- this fn also handles case where user writes return statement without value
- valueless returns allowed in init to early exit body
- but not allowed to return other value

- compiler report error for that

^code return-from-init (3 before, 1 after)

- all special rules for init impl

**todo: show example user can write and run**

## Optimized Invocations

- correctly impl lox sem, could stop here
- reason making vm to be faster
- lox semantics define method invoc as two ops, access then call
- important to support since user can separate
- treating as separate has runtime cost
- access heap allocs and init bound method
- store this in bound method obj
- call then pulls this out of bound method obj and puts on stack
- [illustrate stack layout of call going through bound method]
- then gc later cleans up bound method
- but 99% of time, user accesses then immediately calls method
- fortunately even single pass compiler can see when user immediately
  invoking method
- if get expr immediately followed by parenthesized call, then probably
  method call
- add optimized instruction for that case that skips creating bound method
  and combines method lookup and call into single fast op
- [illustrate stack layout of optimized call]

- start in front end

^code parse-call (3 before, 1 after)

- if after parsing get expr we see `(`, then compile as method invocation
- compile arg list like for normal call
- then emit new instr
- takes two byte ops
  - first index of method name string in const table
  - then number of args passed to invocation
- same two ops as `OP_GET_PROPERTY` and  `OP_CALL` in that order
- is fusion of those two instrs
- define new inst

^code invoke-op (1 before, 1 after)

- add to dis

^code disassemble-invoke (2 before, 1 after)

- needs special support since has unique op format

^code invoke-instruction

- show both number of args and method name
- then add to interp

^code interpret-invoke (4 before, 1 after)

- most work in helper
- just reads ops
- calls helper which returns true if successful cal
- otherwise, runtime error which interp aborts
- if call successful, new frame on stack for called method so here need to
  refresh cached pointer to current frame

- work happens here

^code invoke

- first look up receiver from stack

**todo: illustrate stack layout**

- under all the args passed to method so peek that far down to skip past them
- if receiver not an instance runtime error
- otherwise, look up instance's class and hand off to second helper
- [will reuse helper later]

^code invoke-from-class

- combines logic of OP_GET_PROPERTY and OP_CALL
- first look up method in class table
- if not found, runtime error
- otherwise, instead of creating bound method obj, immediately call found
  closure
- note not only don't need alloc bound method, don't even need to touch stack
- stack layout of receiver and args already exactly what needed for method call
- [why used slot zero for "this"]

- vm behave same as before
- hopefully faster
- contrived benchmark does bunch of method calls
- on my machine, without OP_INVOKE, runs in 3.13613s
- with 0.693169
- 4.5x faster
- huge improvement in vm

### Invoking fields

- opt does have to behave same
- no good if breaks valid programs
- consider

```lox
class Oops {
  init() {
    fun f() {
      print "not a method";
    }

    this.field = f;
  }
}

var oops = Oops();
oops.field();
```

- last line looks like method call
- not, actually accessing field, which contains fn, invoking fn
- compiler thinks it is method call
- compiles to invoke
- invoke does not look for field
- broken

- `OP_GET_PROPERTY` handles both field and method
- `OP_INVOKE` needs to as well
- easy fix

^code invoke-field (1 before, 1 after)

- before looking up method, look for field
- if found, access field value
- put on stack in same way where `OP_GET_PROPERTY` would put it
- try to call value like fn
- `callValue()` checks type handles cases where not fn, or where class, etc.

- now opt works
- common structure for optimization
- have optimized fast path that matches known common pattern
- but guarded by conditional code to ensure actually is pattern
- if not, bails out to slower normal path

- with that have most oop features in vm
- better, have pretty efficient impl of them

### challenges

1.  looking up init method by name in class table every time instance created
    - creating instances frequent op in oop program
    - come up with way to optimize
    - measure perf difference

1.  even in dynamically typed lang, common that every method call at particular
    location in program ends up calling same method on exact same class
    - while any call can be polymorphic, most are not
    - how do advanced dyn langs handle?
    - try to implement similar opt

1.  in OP_INVOKE have to do table lookup in instance field table before looking
    up method
    - every call two hash table lookups
    - almost never needed: most fields don't contain fns
    - necessary because made language choice that fields and methods accessed
      same syntax
    - fields shadow methods
    - right choice? what would you do?

### design note: novelty budget

- when first learned how to impl lang and start designed, really empowering
- could make language do anything i wanted
- everything about every lang ever used suddenly felt like shackles
- like had to wear uniform to school every day didn't even realize
- wait, you don't need to use curly braces for blocks?
- could have classes but no virtual methods?
- learning how to impl lang like being told could wear whatever i wanted
- naturally ran with it
- made weirdest, most random lang choices
- different for difference's sake

- very fun, highly recommend
- need more avant garde art langs

- if want lang to be successful -- many users -- very different
- many users means lang has to be loaded into brain of many people
- hard!
- people very cautious of what let get in there
- lot of work loading new material in there
- don't want to waste time loading useless stuff in
- want to get as much use from as little loading as possible

- as lang designer, your goal to give maximimum power to them while minimizing
  learning
- obvious way to do this is simplicty:
- less total stuff less to learn
- one reason small scripting languages get popular even though not powerful
  less to learn
- big advantage of dynamic typed langs
- can start writing useful progs faster

- other important trick to minimize how much have to load into head
- remember goal is to minimize how much have to *have* in head
- to minimize *delta*
- mentioned before [link to parsing-expressions.html#design-note]
- your lang can use what's already in head

- many people already know at least one other lang
- anything your lang has in common with that can be learned for free
- user just need to recognize that *is* same

- in other words, familiarity is other important tool to low cognitive load
- taken to furthest extent, your new lang exactly identical to some existing
  lang
- not path to success -- if completely same, no reason to switch at all

- fundamental balancing act of lang design
- be as familiar as possible to lower learning cost
- while being different enough to have compelling advantage over existing
  langs

- think of in terms of "novelty" or "strangeness" budget
https://words.steveklabnik.com/the-language-strangeness-budget
- users have very low threshold for weird things in lang willing to accept
- programmers have intense emotional relationship with lang
- [don't mean in jest, literally true
  we care about langs like shipwrights care about wood]
- very easily turned off

- your lang needs to be different to be compelling, but each difference has
  high cost
- risk scaring off users
- have budget of how much new stuff or differences can ask users to learn

- must spend judiciously on features that add compelling value in return
- if just change braces to square brackets for no reason, spending novelty
  budget while getting nothing in return

- not as fun as changing everything heart wants to change
- up to you to decide whether to chase popularity or dreams
