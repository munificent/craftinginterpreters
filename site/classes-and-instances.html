<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Classes and Instances &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>

<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-3.4.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="contents">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">Classes and Instances<small>27</small></a></h3>

<ul>
    <li><a href="#class-objects"><small>27.1</small> Class Objects</a></li>
    <li><a href="#class-declarations"><small>27.2</small> Class Declarations</a></li>
    <li><a href="#instances-of-classes"><small>27.3</small> Instances of Classes</a></li>
    <li><a href="#get-and-set-expressions"><small>27.4</small> Get and Set Expressions</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="garbage-collection.html" title="Garbage Collection" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="methods-and-initializers.html" title="Methods and Initializers" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
<a href="garbage-collection.html" title="Garbage Collection" class="prev">←</a>
<a href="methods-and-initializers.html" title="Methods and Initializers" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">Classes and Instances<small>27</small></a></h3>

<ul>
    <li><a href="#class-objects"><small>27.1</small> Class Objects</a></li>
    <li><a href="#class-declarations"><small>27.2</small> Class Declarations</a></li>
    <li><a href="#instances-of-classes"><small>27.3</small> Instances of Classes</a></li>
    <li><a href="#get-and-set-expressions"><small>27.4</small> Get and Set Expressions</a></li>
    <li class="divider"></li>
    <li class="end-part"><a href="#challenges">Challenges</a></li>
</ul>


<div class="prev-next">
    <a href="garbage-collection.html" title="Garbage Collection" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="methods-and-initializers.html" title="Methods and Initializers" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">27</div>
  <h1>Classes and Instances</h1>

<div class="sign-up closable">
  <h1>This book is a work in progress!</h1>
    <span class="dismiss">&times;</span>
    <p>If you see a mistake, find something unclear, or have a suggestion, please <a href="https://github.com/munificent/craftinginterpreters/issues" target="_blank">let me know</a>. To follow its progress, please join the mailing list:</p>

  <!-- Begin MailChimp Signup Form -->
  <div id="mc_embed_signup">
  <form action="//gameprogrammingpatterns.us7.list-manage.com/subscribe/post?u=0952ca43ed2536d6717766b88&amp;id=6e96334109" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_0952ca43ed2536d6717766b88_6e96334109" tabindex="-1" value=""></div>
    <input type="submit" value="Sign me up!" name="subscribe" id="mc-embedded-subscribe" class="button">
  </form>
  </div>
  <!--End mc_embed_signup-->
  <p class="small">(I post about once a month. Don&#8217;t worry, I won&#8217;t spam you.)</p>
</div>

<blockquote>
<p>Caring too much for objects can destroy you. Only<span class="em">&mdash;</span>if you care for a thing
enough, it takes on a life of its own, doesn&rsquo;t it? And isn’t the whole point
of things<span class="em">&mdash;</span>beautiful things<span class="em">&mdash;</span>that they connect you to some larger beauty?</p>
<p><cite>Donna Tartt, <em>The Goldfinch</em></cite></p>
</blockquote>
<p>The last area left to implement in clox is object-oriented programming. <span
name="oop">OOP</span> is a bundle of intertwined features: classes, instances,
fields, methods, initializers, and inheritance. Using relatively high-level
Java, we packed all that into two chapters. Now that we&rsquo;re coding in C, which
feels like building a model of the Eiffel tower out of toothpicks, we&rsquo;ll devote
three chapters to covering the same territory. This makes for a leisurely stroll
through the implementation. After strenuous chapters like <a href="closures.html">closures</a> and the
<a href="garbage-collection.html">garbage collector</a>, you have earned a rest. In fact, the book should be easy
from here on out.</p>
<aside name="oop">
<p>People who have strong opinions about object-oriented programming<span class="em">&mdash;</span>read
&ldquo;everyone&rdquo;<span class="em">&mdash;</span>tend to assume OOP means some very specific list of language
features, but really there&rsquo;s a whole space to explore and each language has its
own ingredients and recipes.</p>
<p>Self has objects but no classes. CLOS has methods but doesn&rsquo;t attach them to
specific classes. C++ initially had no runtime polymorphism<span class="em">&mdash;</span>no virtual
methods. Python has multiple inheritance, but Java does not. Ruby attaches
methods to classes, but you can also define methods on a single object.</p>
</aside>
<p>In this chapter, we cover the first three features: classes, instances, and
fields. This is the stateful side of object orientation. Then in the next two
chapters, we will hang behavior and code reuse off of those objects.</p>
<h2><a href="#class-objects" name="class-objects"><small>27&#8202;.&#8202;1</small> Class Objects</a></h2>
<p>In a class-based object-oriented language, everything begins with classes. They
define what sorts of objects exist in the program and are the factories used to
produce new instances. Going bottom-up, we&rsquo;ll start with their runtime
representation and then hook that into the language.</p>
<p>By this point, we&rsquo;re well-acquainted with the process of adding a new object
type to the VM. We start with a struct:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="p">}</span> <span class="n">ObjClosure</span><span class="p">;</span>                                 
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClosure</em></div>
<pre class="insert"><br><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">sObjClass</span> <span class="p">{</span>                    
  <span class="n">Obj</span> <span class="n">obj</span><span class="p">;</span>                                    
  <span class="n">ObjString</span><span class="o">*</span> <span class="n">name</span><span class="p">;</span>                            
<span class="p">}</span> <span class="n">ObjClass</span><span class="p">;</span>                                   
</pre><pre class="insert-after"><br><span></span><span class="n">ObjClosure</span><span class="o">*</span> <span class="nf">newClosure</span><span class="p">(</span><span class="n">ObjFunction</span><span class="o">*</span> <span class="n">function</span><span class="p">);</span>
</pre></div>

<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClosure</em></div>

<p>After the Obj header, we store the class&rsquo;s name. This isn&rsquo;t strictly needed for
the user&rsquo;s program, but it lets us show the name at runtime for things like
stack traces.</p>
<p>The new type needs a corresponding case in the ObjType enum:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert"><span></span>  <span class="n">OBJ_CLASS</span><span class="p">,</span>  
</pre><pre class="insert-after"><span></span>  <span class="n">OBJ_CLOSURE</span><span class="p">,</span>
</pre></div>

<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>And that type gets a corresponding pair of macros. First, for testing an
object&rsquo;s type:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="cp">#define OBJ_TYPE(value)         (AS_OBJ(value)-&gt;type)        </span>
<br></pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span></span><span class="cp">#define IS_CLASS(value)         isObjType(value, OBJ_CLASS)  </span>
</pre><pre class="insert-after"><span></span><span class="cp">#define IS_CLOSURE(value)       isObjType(value, OBJ_CLOSURE)</span>
</pre></div>

<div class="source-file-narrow"><em>object.h</em></div>

<p>And then for casting a Value to an ObjClass pointer:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="cp">#define IS_STRING(value)        isObjType(value, OBJ_STRING)</span>
<br></pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span></span><span class="cp">#define AS_CLASS(value)         ((ObjClass*)AS_OBJ(value))  </span>
</pre><pre class="insert-after"><span></span><span class="cp">#define AS_CLOSURE(value)       ((ObjClosure*)AS_OBJ(value))</span>
</pre></div>

<div class="source-file-narrow"><em>object.h</em></div>

<p>The VM creates new class objects using this function:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="p">}</span> <span class="n">ObjClass</span><span class="p">;</span>                                   
<br></pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClass</em></div>
<pre class="insert"><span></span><span class="n">ObjClass</span><span class="o">*</span> <span class="nf">newClass</span><span class="p">(</span><span class="n">ObjString</span><span class="o">*</span> <span class="n">name</span><span class="p">);</span>          
</pre><pre class="insert-after"><span></span><span class="n">ObjClosure</span><span class="o">*</span> <span class="nf">newClosure</span><span class="p">(</span><span class="n">ObjFunction</span><span class="o">*</span> <span class="n">function</span><span class="p">);</span>
</pre></div>

<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClass</em></div>

<p>The implementation lives over here:</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>allocateObject</em>()</div>
<pre><span></span><span class="n">ObjClass</span><span class="o">*</span> <span class="nf">newClass</span><span class="p">(</span><span class="n">ObjString</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>                 
  <span class="n">ObjClass</span><span class="o">*</span> <span class="n">klass</span> <span class="o">=</span> <span class="n">ALLOCATE_OBJ</span><span class="p">(</span><span class="n">ObjClass</span><span class="p">,</span> <span class="n">OBJ_CLASS</span><span class="p">);</span>
  <span class="n">klass</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span><span name="klass"> </span>
  <span class="k">return</span> <span class="n">klass</span><span class="p">;</span>                                       
<span class="p">}</span>                                                     
</pre></div>

<div class="source-file-narrow"><em>object.c</em>, add after <em>allocateObject</em>()</div>

<p>Pretty much all boilerplate. It takes in the class&rsquo;s name as a string and stores
it. Every time the user declares a new class, the VM will create a new one of
these ObjClass structs to represent it.</p>
<aside name="klass">
<p><img src="image/classes-and-instances/klass.png" alt="'Klass' in a zany kidz font."/>

I named the variable "klass" not just to give the VM a zany preschool "kidz
korner" feel. While "class" is not a reserved word in C, it is in C++, and you
can compile clox as either.</p>
</aside>
<p>When the VM no longer needs a class, it frees it like so:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="k">switch</span> <span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>    
</pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">OBJ_CLASS</span><span class="p">:</span> <span class="p">{</span>        
      <span class="n">FREE</span><span class="p">(</span><span class="n">ObjClass</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>                 
    <span class="p">}</span><span name="braces"> </span>
<br></pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">OBJ_CLOSURE</span><span class="p">:</span> <span class="p">{</span>      
</pre></div>

<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<aside name="braces">
<p>The braces here are pointless now, but will be useful in the next chapter when
we add some more code to the switch case.</p>
</aside>
<p>We have a memory manager now, so we also need to support tracing through class
objects:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="k">switch</span> <span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>                 
</pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">OBJ_CLASS</span><span class="p">:</span> <span class="p">{</span>                     
      <span class="n">ObjClass</span><span class="o">*</span> <span class="n">klass</span> <span class="o">=</span> <span class="p">(</span><span class="n">ObjClass</span><span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">;</span>
      <span class="n">markObject</span><span class="p">((</span><span class="n">Obj</span><span class="o">*</span><span class="p">)</span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>      
      <span class="k">break</span><span class="p">;</span>                              
    <span class="p">}</span>                                     
<br></pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">OBJ_CLOSURE</span><span class="p">:</span> <span class="p">{</span>                   
</pre></div>

<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>When the GC reaches a class object, we mark its name to keep that string alive
too.</p>
<p>The last operation the VM can perform on a class is printing it:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="k">switch</span> <span class="p">(</span><span class="n">OBJ_TYPE</span><span class="p">(</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>                     
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">OBJ_CLASS</span><span class="p">:</span>                              
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">AS_CLASS</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">chars</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>                                     
</pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">OBJ_CLOSURE</span><span class="p">:</span>                            
</pre></div>

<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p>A class simply prints its own name.</p>
<h2><a href="#class-declarations" name="class-declarations"><small>27&#8202;.&#8202;2</small> Class Declarations</a></h2>
<p>Runtime representation in hand, we are ready to add support for classes to the
language. As usual, we start in the parser:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">declaration</span><span class="p">()</span> <span class="p">{</span>     
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>declaration</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">TOKEN_CLASS</span><span class="p">))</span> <span class="p">{</span>     
    <span class="n">classDeclaration</span><span class="p">();</span>         
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="p">(</span><span class="n">TOKEN_FUN</span><span class="p">))</span> <span class="p">{</span>
</pre><pre class="insert-after"><span></span>    <span class="n">funDeclaration</span><span class="p">();</span>           
</pre></div>

<div class="source-file-narrow"><em>compiler.c</em>, in <em>declaration</em>(), replace 1 line</div>

<p>Class declarations are statements and the parser recognizes one by the leading
<code>class</code> keyword. The rest of the compilation happens over here:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>function</em>()</div>
<pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">classDeclaration</span><span class="p">()</span> <span class="p">{</span>                              
  <span class="n">consume</span><span class="p">(</span><span class="n">TOKEN_IDENTIFIER</span><span class="p">,</span> <span class="s">&quot;Expect class name.&quot;</span><span class="p">);</span>            
  <span class="kt">uint8_t</span> <span class="n">nameConstant</span> <span class="o">=</span> <span class="n">identifierConstant</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parser</span><span class="p">.</span><span class="n">previous</span><span class="p">);</span>
  <span class="n">declareVariable</span><span class="p">();</span>

  <span class="n">emitBytes</span><span class="p">(</span><span class="n">OP_CLASS</span><span class="p">,</span> <span class="n">nameConstant</span><span class="p">);</span>                          
  <span class="n">defineVariable</span><span class="p">(</span><span class="n">nameConstant</span><span class="p">);</span>                               

  <span class="n">consume</span><span class="p">(</span><span class="n">TOKEN_LEFT_BRACE</span><span class="p">,</span> <span class="s">&quot;Expect &#39;{&#39; before class body.&quot;</span><span class="p">);</span> 
  <span class="n">consume</span><span class="p">(</span><span class="n">TOKEN_RIGHT_BRACE</span><span class="p">,</span> <span class="s">&quot;Expect &#39;}&#39; after class body.&quot;</span><span class="p">);</span> 
<span class="p">}</span>                                                             
</pre></div>

<div class="source-file-narrow"><em>compiler.c</em>, add after <em>function</em>()</div>

<p>Immediately after the <code>class</code> keyword is the class&rsquo;s name. We take that
identifier and add it to the surrounding function&rsquo;s constant table as a string.
As you just saw, printing a class shows its name, so the compiler needs to stuff
the name string somewhere that the runtime can find. The constant table is the
way to do that.</p>
<p>The class&rsquo;s <span name="variable">name</span> is also used to bind the class
object to a variable of the same name. So we declare a variable with that
identifier right after consuming its token.</p>
<aside name="variable">
<p>We could have made class declarations be <em>expressions</em> instead of statements.
Then users would have to explicitly bind the class to a variable themselves
like:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="vg">Pie</span> <span class="o">=</span> <span class="k">class</span> <span class="vg">Pie</span> <span class="p">{}</span>
</pre></div>


<p>Sort of like lambda functions but for classes. But since we generally want
classes to be named anyway, it makes sense to treat them as declarations.</p>
</aside>
<p>Next, we emit a new instruction to actually create the class object at runtime.
That instruction takes the constant table index of the class&rsquo;s name as an
operand.</p>
<p>After that, but before compiling the body of the class, we define the variable
for the class&rsquo;s name. <em>Declaring</em> the variable adds it to the scope but recall
from <a href="local-variables.html#another-scope-edge-case">a previous chapter</a> that we can&rsquo;t <em>use</em> the variable until it&rsquo;s
<em>defined</em>. For classes, we define the variable before the body. That way, users
can refer to the containing class inside the bodies of methods. That&rsquo;s useful
for things like factory methods.</p>
<p>Finally, we compile the body. We don&rsquo;t have methods yet, so right now it&rsquo;s
simply an empty pair of braces. Lox doesn&rsquo;t require fields to be declared in the
class, so we&rsquo;re done with the body<span class="em">&mdash;</span>and the parser<span class="em">&mdash;</span>for now.</p>
<p>The compiler is emitting a new instruction, so let&rsquo;s define that:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="n">OP_RETURN</span><span class="p">,</span>
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert"><span></span>  <span class="n">OP_CLASS</span><span class="p">,</span> 
</pre><pre class="insert-after"><span></span><span class="p">}</span> <span class="n">OpCode</span><span class="p">;</span>   
</pre></div>

<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>And add it to the disassembler:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="k">case</span> <span class="nl">OP_RETURN</span><span class="p">:</span>                                         
      <span class="k">return</span> <span class="n">simpleInstruction</span><span class="p">(</span><span class="s">&quot;OP_RETURN&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>        
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">OP_CLASS</span><span class="p">:</span>                                          
      <span class="k">return</span> <span class="n">constantInstruction</span><span class="p">(</span><span class="s">&quot;OP_CLASS&quot;</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre><pre class="insert-after"><span></span>    <span class="k">default</span><span class="o">:</span>                                                
</pre></div>

<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<p>For such a large-seeming feature, the interpreter support is easy:</p>
<div class="codehilite"><pre class="insert-before"><span></span>        <span class="n">frame</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vm</span><span class="p">.</span><span class="n">frames</span><span class="p">[</span><span class="n">vm</span><span class="p">.</span><span class="n">frameCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span> 
        <span class="k">break</span><span class="p">;</span>                                 
      <span class="p">}</span>                                        
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><br><span></span>      <span class="k">case</span> <span class="nl">OP_CLASS</span><span class="p">:</span>                           
        <span class="n">push</span><span class="p">(</span><span class="n">OBJ_VAL</span><span class="p">(</span><span class="n">newClass</span><span class="p">(</span><span class="n">READ_STRING</span><span class="p">())));</span>
        <span class="k">break</span><span class="p">;</span>                                 
</pre><pre class="insert-after"><span></span>    <span class="p">}</span>                                          
</pre></div>

<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>We load the string for the class&rsquo;s name from the constant table and pass that to
<code>newClass()</code>. That creates a new class object with the given name. We push that
onto the stack and we&rsquo;re good. If the class is bound to a global variable, then
the compiler&rsquo;s call to <code>defineVariable()</code> will emit code to store that object
from the stack into the global variable table. Otherwise, it&rsquo;s right where it
needs to be on the stack for a new <span name="local">local</span> variable.</p>
<aside name="local">
<p>&ldquo;Local&rdquo; classes<span class="em">&mdash;</span>classes declared inside the body of a function or block, are
an unusual concept. Many languages don&rsquo;t allow them at all. But since Lox is a
dynamically-typed scripting language, it treats the top level of a program and
the bodies of functions and blocks uniformly. Classes are just another kind of
declaration and since you can declare variables and functions inside blocks, you
can declare classes in there too.</p>
</aside>
<p>There you have it, our VM supports classes now. You can run this:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Brioche</span> <span class="p">{}</span>
<span class="k">print</span> <span class="vg">Brioche</span><span class="p">;</span>
</pre></div>


<p>Unfortunately, printing is about <em>all</em> you can do with classes, so next is
making them more useful.</p>
<h2><a href="#instances-of-classes" name="instances-of-classes"><small>27&#8202;.&#8202;3</small> Instances of Classes</a></h2>
<p>Classes serve two main purposes in a language:</p>
<ol>
<li>
<p><strong>They are how you create new instances.</strong> Sometimes this involves a <code>new</code>
    keyword, other times it&rsquo;s a method call on the class object, but you usually
    mention the class by name <em>somehow</em> to get a new instance.</p>
</li>
<li>
<p><strong>They contain methods.</strong> These define how all instances of the class
    behave.</p>
</li>
</ol>
<p>We won&rsquo;t get to methods until the next chapter, so for now we will only worry
about the first part. Before classes can create instances, we need a
representation for them:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="p">}</span> <span class="n">ObjClass</span><span class="p">;</span>                         
</pre><div class="source-file"><em>object.h</em><br>
add after struct <em>ObjClass</em></div>
<pre class="insert"><br><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>                    
  <span class="n">Obj</span> <span class="n">obj</span><span class="p">;</span>                          
  <span class="n">ObjClass</span><span class="o">*</span> <span class="n">klass</span><span class="p">;</span>                  
  <span class="n">Table</span> <span class="n">fields</span><span class="p">;</span><span name="fields"> </span>
<span class="p">}</span> <span class="n">ObjInstance</span><span class="p">;</span>                      
</pre><pre class="insert-after"><br><span></span><span class="n">ObjClass</span><span class="o">*</span> <span class="nf">newClass</span><span class="p">(</span><span class="n">ObjString</span><span class="o">*</span> <span class="n">name</span><span class="p">);</span>
</pre></div>

<div class="source-file-narrow"><em>object.h</em>, add after struct <em>ObjClass</em></div>

<p>Each instance has a pointer to the class that it is an instance of. Instances
know their class. We won&rsquo;t use this much in this chapter, but it will become
critical when we add methods.</p>
<p>More important to this chapter is how instances store their state. Lox lets
users freely add fields to an instance at runtime. This means we need a storage
mechanism that can grow. We could use a dynamic array, but we also want to look
up fields by name as quickly as possible. There&rsquo;s a data structure that&rsquo;s just
perfect for quickly accessing a set of values by name and<span class="em">&mdash;</span>even more conveniently<span class="em">&mdash;</span>we&rsquo;ve already implemented it. Each instance stores
its fields using a hash table.</p>
<aside name="fields">
<p>Being able to freely add fields to an object at runtime is a big practical
difference between most dynamic and static languages. Statically-typed languages
usually require fields to be explicitly declared. This way, the compiler knows
exactly what fields each instance has. It can use that to determine the precise
amount of memory needed for each instance and the offsets in that memory where
each field can be found.</p>
<p>In Lox and other dynamic languages, accessing a field is usually a hash table
lookup. Constant time, but still pretty heavyweight. In a language like C++,
accessing a field is as fast as offsetting a pointer by an integer constant.</p>
</aside>
<p>We only need to add an include and we&rsquo;ve got it:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="cp">#include</span> <span class="cpf">&quot;chunk.h&quot;</span><span class="cp"></span>
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span></span><span class="cp">#include</span> <span class="cpf">&quot;table.h&quot;</span><span class="cp"></span>
</pre><pre class="insert-after"><span></span><span class="cp">#include</span> <span class="cpf">&quot;value.h&quot;</span><span class="cp"></span>
</pre></div>

<div class="source-file-narrow"><em>object.h</em></div>

<p>This new struct gets a new object type:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="n">OBJ_FUNCTION</span><span class="p">,</span>
</pre><div class="source-file"><em>object.h</em><br>
in enum <em>ObjType</em></div>
<pre class="insert"><span></span>  <span class="n">OBJ_INSTANCE</span><span class="p">,</span>
</pre><pre class="insert-after"><span></span>  <span class="n">OBJ_NATIVE</span><span class="p">,</span>  
</pre></div>

<div class="source-file-narrow"><em>object.h</em>, in enum <em>ObjType</em></div>

<p>I want to slow down a bit here because Lox&rsquo;s notion of &ldquo;type&rdquo; and the VM&rsquo;s
<em>implementation</em> notion of type brush against each other in ways that can be
confusing. Inside the C code that makes clox, there are a number of different
types of Obj<span class="em">&mdash;</span>ObjString, ObjClosure, etc. Each has its own internal
representation and semantics.</p>
<p>In the Lox <em>language</em>, users can define their own classes<span class="em">&mdash;</span>say Cake and Pie<span class="em">&mdash;</span>and then create instances of those classes. From the user&rsquo;s perspective, an
instance of Cake is a different &ldquo;type&rdquo; of object than an instance of Pie. But,
from the VM&rsquo;s perspective every class the user defines is simply another value
of type ObjClass. Likewise, each instance in the user&rsquo;s program, no matter what
class it is an instance of, is an ObjInstance. That one VM object type covers
instances of all classes. The two worlds map to each other something like this:</p>
<p><img src="image/classes-and-instances/lox-clox.png" alt="A set of class declarations and instances, and the runtime representations each maps to."/></p>
<p>Got it? OK, back to the implementation. We also get our usual macros:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="cp">#define IS_FUNCTION(value)      isObjType(value, OBJ_FUNCTION)</span>
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span></span><span class="cp">#define IS_INSTANCE(value)      isObjType(value, OBJ_INSTANCE)</span>
</pre><pre class="insert-after"><span></span><span class="cp">#define IS_NATIVE(value)        isObjType(value, OBJ_NATIVE)  </span>
</pre></div>

<div class="source-file-narrow"><em>object.h</em></div>

<p>And:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="cp">#define AS_FUNCTION(value)      ((ObjFunction*)AS_OBJ(value))          </span>
</pre><div class="source-file"><em>object.h</em></div>
<pre class="insert"><span></span><span class="cp">#define AS_INSTANCE(value)      ((ObjInstance*)AS_OBJ(value))          </span>
</pre><pre class="insert-after"><span></span><span class="cp">#define AS_NATIVE(value)        (((ObjNative*)AS_OBJ(value))-&gt;function)</span>
</pre></div>

<div class="source-file-narrow"><em>object.h</em></div>

<p>Since fields are added after the instance is created, the &ldquo;constructor&rdquo; function
only needs to know the class:</p>
<div class="codehilite"><pre class="insert-before"><span></span><span class="n">ObjFunction</span><span class="o">*</span> <span class="nf">newFunction</span><span class="p">();</span>               
</pre><div class="source-file"><em>object.h</em><br>
add after <em>newFunction</em>()</div>
<pre class="insert"><span></span><span class="n">ObjInstance</span><span class="o">*</span> <span class="nf">newInstance</span><span class="p">(</span><span class="n">ObjClass</span><span class="o">*</span> <span class="n">klass</span><span class="p">);</span>
</pre><pre class="insert-after"><span></span><span class="n">ObjNative</span><span class="o">*</span> <span class="nf">newNative</span><span class="p">(</span><span class="n">NativeFn</span> <span class="n">function</span><span class="p">);</span>  
</pre></div>

<div class="source-file-narrow"><em>object.h</em>, add after <em>newFunction</em>()</div>

<p>We implement that function here:</p>
<div class="codehilite"><div class="source-file"><em>object.c</em><br>
add after <em>newFunction</em>()</div>
<pre><span></span><span class="n">ObjInstance</span><span class="o">*</span> <span class="nf">newInstance</span><span class="p">(</span><span class="n">ObjClass</span><span class="o">*</span> <span class="n">klass</span><span class="p">)</span> <span class="p">{</span>                       
  <span class="n">ObjInstance</span><span class="o">*</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">ALLOCATE_OBJ</span><span class="p">(</span><span class="n">ObjInstance</span><span class="p">,</span> <span class="n">OBJ_INSTANCE</span><span class="p">);</span>
  <span class="n">instance</span><span class="o">-&gt;</span><span class="n">klass</span> <span class="o">=</span> <span class="n">klass</span><span class="p">;</span>                                        
  <span class="n">initTable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">);</span>                                   
  <span class="k">return</span> <span class="n">instance</span><span class="p">;</span>                                                
<span class="p">}</span>                                                                 
</pre></div>

<div class="source-file-narrow"><em>object.c</em>, add after <em>newFunction</em>()</div>

<p>We store a reference to the instance&rsquo;s class. Then we initialize the field
table to an empty hash table. A new baby object is born!</p>
<p>At the sadder end of the instance&rsquo;s lifespan, it gets freed:</p>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="n">FREE</span><span class="p">(</span><span class="n">ObjFunction</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>                   
      <span class="k">break</span><span class="p">;</span>                                       
    <span class="p">}</span>                                              
<br></pre><div class="source-file"><em>memory.c</em><br>
in <em>freeObject</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">OBJ_INSTANCE</span><span class="p">:</span> <span class="p">{</span>                           
      <span class="n">ObjInstance</span><span class="o">*</span> <span class="n">instance</span> <span class="o">=</span> <span class="p">(</span><span class="n">ObjInstance</span><span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">;</span>
      <span class="n">freeTable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">);</span>                
      <span class="n">FREE</span><span class="p">(</span><span class="n">ObjInstance</span><span class="p">,</span> <span class="n">object</span><span class="p">);</span>                   
      <span class="k">break</span><span class="p">;</span>                                       
    <span class="p">}</span>                                              
<br></pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">OBJ_NATIVE</span><span class="p">:</span>                               
</pre></div>

<div class="source-file-narrow"><em>memory.c</em>, in <em>freeObject</em>()</div>

<p>The instance owns its field table so when freeing the instance, we also free the
table.</p>
<p>Speaking of memory management, we also need to support instances in the garbage
collector:</p>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="n">markArray</span><span class="p">(</span><span class="o">&amp;</span><span class="n">function</span><span class="o">-&gt;</span><span class="n">chunk</span><span class="p">.</span><span class="n">constants</span><span class="p">);</span>       
      <span class="k">break</span><span class="p">;</span>                                       
    <span class="p">}</span>                                              
<br></pre><div class="source-file"><em>memory.c</em><br>
in <em>blackenObject</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">OBJ_INSTANCE</span><span class="p">:</span> <span class="p">{</span>                           
      <span class="n">ObjInstance</span><span class="o">*</span> <span class="n">instance</span> <span class="o">=</span> <span class="p">(</span><span class="n">ObjInstance</span><span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">;</span>
      <span class="n">markObject</span><span class="p">((</span><span class="n">Obj</span><span class="o">*</span><span class="p">)</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">klass</span><span class="p">);</span>           
      <span class="n">markTable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">);</span>                
      <span class="k">break</span><span class="p">;</span>                                       
    <span class="p">}</span>                                              
<br></pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">OBJ_UPVALUE</span><span class="p">:</span>                              
</pre></div>

<div class="source-file-narrow"><em>memory.c</em>, in <em>blackenObject</em>()</div>

<p>If the instance is alive, we need to keep its class around. Also, we need to
keep every object referenced by the instance&rsquo;s fields. Most live objects that
are not roots are reachable because some instance references the object in a
field. Fortunately, we already have a nice <code>markTable()</code> function to make
tracing them easy.</p>
<p>Less critical but still important is printing:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="k">case</span> <span class="nl">OBJ_FUNCTION</span><span class="p">:</span>                                              
      <span class="n">printFunction</span><span class="p">(</span><span class="n">AS_FUNCTION</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>                            
      <span class="k">break</span><span class="p">;</span>                                                        
</pre><div class="source-file"><em>object.c</em><br>
in <em>printObject</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">OBJ_INSTANCE</span><span class="p">:</span>                                              
      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s instance&quot;</span><span class="p">,</span> <span class="n">AS_INSTANCE</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">klass</span><span class="o">-&gt;</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">chars</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>                                                        
</pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">OBJ_NATIVE</span><span class="p">:</span>                                                
</pre></div>

<div class="source-file-narrow"><em>object.c</em>, in <em>printObject</em>()</div>

<p><span name="print">An</span> instance prints its name followed by &ldquo;instance&rdquo;.
(The &ldquo;instance&rdquo; part is mainly so that classes and instances don&rsquo;t print the
same.)</p>
<aside name="print">
<p>Most object-oriented languages let a class define some sort of <code>toString()</code>
method that lets the class specify how its instances are converted to a string
and printed. If Lox was less of a toy language, I would want to support that
too.</p>
</aside>
<p>The real fun happens over in the interpreter. Lox has no special <code>new</code> keyword.
The way to create an instance of a class is to invoke the class itself as if it
were a function. The runtime already supports function calls and it checks the
type of object being called to make sure the user doesn&rsquo;t try to invoke a number
or other invalid type.</p>
<p>We extend that with a new valid case:</p>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="k">switch</span> <span class="p">(</span><span class="n">OBJ_TYPE</span><span class="p">(</span><span class="n">callee</span><span class="p">))</span> <span class="p">{</span>                                  
</pre><div class="source-file"><em>vm.c</em><br>
in <em>callValue</em>()</div>
<pre class="insert"><span></span>      <span class="k">case</span> <span class="nl">OBJ_CLASS</span><span class="p">:</span> <span class="p">{</span>                                          
        <span class="n">ObjClass</span><span class="o">*</span> <span class="n">klass</span> <span class="o">=</span> <span class="n">AS_CLASS</span><span class="p">(</span><span class="n">callee</span><span class="p">);</span>                      
        <span class="n">vm</span><span class="p">.</span><span class="n">stackTop</span><span class="p">[</span><span class="o">-</span><span class="n">argCount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">OBJ_VAL</span><span class="p">(</span><span class="n">newInstance</span><span class="p">(</span><span class="n">klass</span><span class="p">));</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>                                             
      <span class="p">}</span>                                                          
</pre><pre class="insert-after"><span></span>      <span class="k">case</span> <span class="nl">OBJ_CLOSURE</span><span class="p">:</span>                                          
</pre></div>

<div class="source-file-narrow"><em>vm.c</em>, in <em>callValue</em>()</div>

<p>If the value being called<span class="em">&mdash;</span>the object that results when evaluating the
expression to the left of the opening parenthesis<span class="em">&mdash;</span>is a class, then we treat
it as a constructor call. We <span name="args">create</span> a new instance of
the called class and store the result in the stack.</p>
<aside name="args">
<p>We ignore any arguments passed to the call for now. We&rsquo;ll revisit this in the
<a href="methods-and-initializers.html">next chapter</a> when we add support for initializers.</p>
</aside>
<p>We&rsquo;re one step farther. Now we can define classes and create instances of them:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Brioche</span> <span class="p">{}</span>
<span class="k">print</span> <span class="vg">Brioche</span><span class="p">();</span>
</pre></div>


<p>Note the parentheses after <code>Brioche</code> on the second line now. This prints
&ldquo;Brioche instance&rdquo;.</p>
<h2><a href="#get-and-set-expressions" name="get-and-set-expressions"><small>27&#8202;.&#8202;4</small> Get and Set Expressions</a></h2>
<p>Our object representation for instances can already store state, so all that
remains is exposing that functionality to the user. Fields are accessed and
modified using get and set expressions. Not one to break with tradition, Lox
uses the classic &ldquo;dot&rdquo; syntax:</p>
<div class="codehilite"><pre><span></span><span class="n">eclair</span><span class="p">.</span><span class="n">filling</span> <span class="o">=</span> <span class="s">&quot;pastry creme&quot;</span><span class="p">;</span>
<span class="k">print</span> <span class="n">eclair</span><span class="p">.</span><span class="n">filling</span><span class="p">;</span>
</pre></div>


<p>The period<span class="em">&mdash;</span>full stop for my English friends<span class="em">&mdash;</span>works <span
name="sort">sort</span> of like an infix operator. There is an expression to the
left that is evaluated first and produces an instance. After that is the <code>.</code>
followed by a field name. Since there is a preceding operand, we hook this into
the parse table as an infix expression:</p>
<aside name="sort">
<p>I say &ldquo;sort of&rdquo; because the right-hand side after the <code>.</code> is not an expression,
but a single identifier whose semantics are handled by the get or set expression
itself. It&rsquo;s really closer to a postfix expression.</p>
</aside>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_COMMA</span>
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="n">dot</span><span class="p">,</span>     <span class="n">PREC_CALL</span> <span class="p">},</span>       <span class="c1">// TOKEN_DOT  </span>
</pre><pre class="insert-after"><span></span>  <span class="p">{</span> <span class="n">unary</span><span class="p">,</span>    <span class="n">binary</span><span class="p">,</span>  <span class="n">PREC_TERM</span> <span class="p">},</span>       <span class="c1">// TOKEN_MINUS</span>
</pre></div>

<div class="source-file-narrow"><em>compiler.c</em>, replace 1 line</div>

<p>As in other languages, the <code>.</code> operator binds tightly, with precedence as high
as the parentheses in a function call. After the parser consumes the dot token,
it dispatches to:</p>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>call</em>()</div>
<pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">dot</span><span class="p">(</span><span class="kt">bool</span> <span class="n">canAssign</span><span class="p">)</span> <span class="p">{</span>                              
  <span class="n">consume</span><span class="p">(</span><span class="n">TOKEN_IDENTIFIER</span><span class="p">,</span> <span class="s">&quot;Expect property name after &#39;.&#39;.&quot;</span><span class="p">);</span>
  <span class="kt">uint8_t</span> <span class="n">name</span> <span class="o">=</span> <span class="n">identifierConstant</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parser</span><span class="p">.</span><span class="n">previous</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">canAssign</span> <span class="o">&amp;&amp;</span> <span class="n">match</span><span class="p">(</span><span class="n">TOKEN_EQUAL</span><span class="p">))</span> <span class="p">{</span>                       
    <span class="n">expression</span><span class="p">();</span>                                              
    <span class="n">emitBytes</span><span class="p">(</span><span class="n">OP_SET_PROPERTY</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>                          
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                                     
    <span class="n">emitBytes</span><span class="p">(</span><span class="n">OP_GET_PROPERTY</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>                          
  <span class="p">}</span>                                                            
<span class="p">}</span>                                                              
</pre></div>

<div class="source-file-narrow"><em>compiler.c</em>, add after <em>call</em>()</div>

<p>The parser expects to find a <span name="prop">property</span> name immediately
after the dot. We load that token&rsquo;s lexeme into the constant table as a string
so that the name is available at runtime.</p>
<aside name="prop">
<p>The compiler uses &ldquo;property&rdquo; instead of &ldquo;field&rdquo; here because remember Lox also
lets you use dot syntax to access a method without calling it. &ldquo;Property&rdquo; is the
general term we use to refer to any named entity you can access on an instance.
Fields are the subset of properties that are backed by the instance&rsquo;s state.</p>
</aside>
<p>We have two new expression forms<span class="em">&mdash;</span>getters and setters<span class="em">&mdash;</span>that this one
function handles. If we see an equals sign after the field name, it must be a
set expression that is assigning to a field. But we don&rsquo;t <em>always</em> allow an
equals sign after the field to be compiled. Consider:</p>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>


<p>This is syntactically invalid according to Lox&rsquo;s grammar, which means our Lox
implementation is obligated to detect and report the error. If <code>dot()</code> silently
parsed the <code>= 3</code> part, we would incorrectly interpret the code as if the user
had written:</p>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>


<p>The problem is that the <code>=</code> side of a set expression has much lower precedence
than the <code>.</code> part. The parser may call <code>dot()</code> in a context that is too high
precedence to permit a setter to appear. To avoid incorrectly allowing that, we
only parse and compile the equals part when <code>canAssign</code> is true. If an equals
token appears when <code>canAssign</code> is false, <code>dot()</code> leaves it alone and returns. In
that case, the compiler will eventually unwind up to <code>parsePrecedence()</code> which
stops at the unexpected <code>=</code> still sitting as the next token and reports an
error.</p>
<p>If we found an <code>=</code> in a context where it <em>is</em> allowed, then we compile the
right-hand expression being stored in the field. After that, we emit a new <span
name="set"><code>OP_SET_PROPERTY</code></span> instruction. That takes a single operand for
the index of the property name in the constant table. If we didn&rsquo;t compile a set
expression, we assume it&rsquo;s a getter and emit an <code>OP_GET_PROPERTY</code> instruction,
which also takes an operand for the property name.</p>
<aside name="set">
<p>You can&rsquo;t <em>set</em> a non-field property, so I suppose that instruction could have
been <code>OP_SET_FIELD</code>, but I thought it looked nicer to be consistent with the get
instruction.</p>
</aside>
<p>Now is a good time to define these two new instructions:</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="n">OP_SET_UPVALUE</span><span class="p">,</span> 
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert"><span></span>  <span class="n">OP_GET_PROPERTY</span><span class="p">,</span>
  <span class="n">OP_SET_PROPERTY</span><span class="p">,</span>
</pre><pre class="insert-after"><span></span>  <span class="n">OP_EQUAL</span><span class="p">,</span>       
</pre></div>

<div class="source-file-narrow"><em>chunk.h</em>, in enum <em>OpCode</em></div>

<p>And add support for disassembling them:</p>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="k">return</span> <span class="nf">byteInstruction</span><span class="p">(</span><span class="s">&quot;OP_SET_UPVALUE&quot;</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>     
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">OP_GET_PROPERTY</span><span class="p">:</span>                                          
      <span class="k">return</span> <span class="n">constantInstruction</span><span class="p">(</span><span class="s">&quot;OP_GET_PROPERTY&quot;</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
    <span class="k">case</span> <span class="nl">OP_SET_PROPERTY</span><span class="p">:</span>                                          
      <span class="k">return</span> <span class="n">constantInstruction</span><span class="p">(</span><span class="s">&quot;OP_SET_PROPERTY&quot;</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">OP_EQUAL</span><span class="p">:</span>                                                 
</pre></div>

<div class="source-file-narrow"><em>debug.c</em>, in <em>disassembleInstruction</em>()</div>

<h3><a href="#interpreting-getter-and-setter-expressions" name="interpreting-getter-and-setter-expressions"><small>27&#8202;.&#8202;4&#8202;.&#8202;1</small> Interpreting getter and setter expressions</a></h3>
<p>Sliding over to the runtime, we&rsquo;ll start with get expressions since those are a
little simpler:</p>
<div class="codehilite"><pre class="insert-before"><span></span>        <span class="o">*</span><span class="n">frame</span><span class="o">-&gt;</span><span class="n">closure</span><span class="o">-&gt;</span><span class="n">upvalues</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">location</span> <span class="o">=</span> <span class="n">peek</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>                                              
      <span class="p">}</span>                                                     
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><br><span></span>      <span class="k">case</span> <span class="nl">OP_GET_PROPERTY</span><span class="p">:</span> <span class="p">{</span>                               
        <span class="n">ObjInstance</span><span class="o">*</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">AS_INSTANCE</span><span class="p">(</span><span class="n">peek</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>       
        <span class="n">ObjString</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="n">READ_STRING</span><span class="p">();</span>

        <span class="n">Value</span> <span class="n">value</span><span class="p">;</span>                                        
        <span class="k">if</span> <span class="p">(</span><span class="n">tableGet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">))</span> <span class="p">{</span>    
          <span class="n">pop</span><span class="p">();</span> <span class="c1">// Instance.                               </span>
          <span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>                                      
          <span class="k">break</span><span class="p">;</span>                                            
        <span class="p">}</span>                                                   
      <span class="p">}</span>                                                     
</pre><pre class="insert-after"><br><span></span>      <span class="k">case</span> <span class="nl">OP_EQUAL</span><span class="p">:</span> <span class="p">{</span>                                      
</pre></div>

<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>When the interpreter reaches this instruction, the expression to the left of the
<code>.</code> has already been executed and the resulting instance is on top of the stack.
We read the field name from the constant pool and look it up in the instance&rsquo;s
field table. If the hash table contains an entry with that name, we pop the
instance and push the entry&rsquo;s value as the result.</p>
<p>Of course, the field might not exist. In Lox, we&rsquo;ve defined that to be a runtime
error. So we add a check for that and abort if it happens:</p>
<div class="codehilite"><pre class="insert-before"><span></span>          <span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>                                        
          <span class="k">break</span><span class="p">;</span>                                              
        <span class="p">}</span>                                                     
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><br><span></span>        <span class="n">runtimeError</span><span class="p">(</span><span class="s">&quot;Undefined property &#39;%s&#39;.&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">chars</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">INTERPRET_RUNTIME_ERROR</span><span class="p">;</span>                       
</pre><pre class="insert-after"><span></span>      <span class="p">}</span>

      <span class="k">case</span> <span class="nl">OP_EQUAL</span><span class="p">:</span> <span class="p">{</span>                                        
</pre></div>

<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p><span name="field">There</span> is another failure mode to handle which you&rsquo;ve
probably noticed. The above code assumes the expression to the left of the dot
did evaluate to an ObjInstance. But there&rsquo;s nothing preventing a user from
writing:</p>
<div class="codehilite"><pre><span></span><span class="k">var</span> <span class="n">obj</span> <span class="o">=</span> <span class="s">&quot;not an instance&quot;</span><span class="p">;</span>
<span class="k">print</span> <span class="n">obj</span><span class="p">.</span><span class="n">field</span><span class="p">;</span>
</pre></div>


<p>The user&rsquo;s program is wrong, but the VM still has to handle it with some grace.
Right now, it will misinterpret the bits of the ObjString as an ObjInstance and,
I don&rsquo;t know, catch on fire or something definitely not graceful.</p>
<p>In Lox, only instances are allowed to have fields. You can&rsquo;t stuff a field onto
a string or number. So we need to check that the value is an instance before
accessing any fields on it:</p>
<aside name="field">
<p>Lox <em>could</em> support adding fields to values of other types. It&rsquo;s our language
and we can do what we want. But it&rsquo;s likely a bad idea. It significantly
complicates the implementation in ways that hurt performance<span class="em">&mdash;</span>for example
string interning gets a lot harder.</p>
<p>Also, it raises gnarly semantic questions around the equality and identity of
values. If I attach a field to the number <code>3</code>, does the result of <code>1 + 2</code> have
that field as well? If so, how does the implementation track that? If not, are
those two resulting &ldquo;threes&rdquo; still considered equal?</p>
</aside>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="k">case</span> <span class="nl">OP_GET_PROPERTY</span><span class="p">:</span> <span class="p">{</span>                             
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_INSTANCE</span><span class="p">(</span><span class="n">peek</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>                      
          <span class="n">runtimeError</span><span class="p">(</span><span class="s">&quot;Only instances have properties.&quot;</span><span class="p">);</span>
          <span class="k">return</span> <span class="n">INTERPRET_RUNTIME_ERROR</span><span class="p">;</span>                 
        <span class="p">}</span>                                                 
<br></pre><pre class="insert-after"><span></span>        <span class="n">ObjInstance</span><span class="o">*</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">AS_INSTANCE</span><span class="p">(</span><span class="n">peek</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>     
</pre></div>

<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>If the value on the stack isn&rsquo;t an instance, we report a runtime error and
safely exit.</p>
<p>Of course, get expressions are not very useful when no instances have any
fields. For that we need setters:</p>
<div class="codehilite"><pre class="insert-before"><span></span>        <span class="n">runtimeError</span><span class="p">(</span><span class="s">&quot;Undefined property &#39;%s&#39;.&quot;</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">chars</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">INTERPRET_RUNTIME_ERROR</span><span class="p">;</span>                       
      <span class="p">}</span>                                                       
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><br><span></span>      <span class="k">case</span> <span class="nl">OP_SET_PROPERTY</span><span class="p">:</span> <span class="p">{</span>                                 
        <span class="n">ObjInstance</span><span class="o">*</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">AS_INSTANCE</span><span class="p">(</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>         
        <span class="n">tableSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">instance</span><span class="o">-&gt;</span><span class="n">fields</span><span class="p">,</span> <span class="n">READ_STRING</span><span class="p">(),</span> <span class="n">peek</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

        <span class="n">Value</span> <span class="n">value</span> <span class="o">=</span> <span class="n">pop</span><span class="p">();</span>                                  
        <span class="n">pop</span><span class="p">();</span>                                                
        <span class="n">push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>                                          
        <span class="k">break</span><span class="p">;</span>                                                
      <span class="p">}</span>                                                       
</pre><pre class="insert-after"><br><span></span>      <span class="k">case</span> <span class="nl">OP_EQUAL</span><span class="p">:</span> <span class="p">{</span>                                        
</pre></div>

<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>This is a little more complex than <code>OP_GET_PROPERTY</code>. On top of the stack, we
first have the instance whose field is being set and then above that is the
value to be stored in the instance&rsquo;s field. Like before, we read the
instruction&rsquo;s operand and find the field name string. Using that, we store the
value on top of the stack into the instance&rsquo;s field table.</p>
<p>After that is a little <span name="stack">stack</span> juggling. We pop the
stored value off, then pop the instance, and finally push the value back on. In
other words, we remove the <em>second</em> element from the stack while leaving the top
alone. A setter is itself an expression whose result is the assigned value, so
we need to leave that value on the stack. Here&rsquo;s what I mean:</p>
<aside name="stack">
<p>The stack operations go like this:</p>
<p><img src="image/classes-and-instances/stack.png" alt="Popping two values and then pushing the first value back on the stack."/></p>
</aside>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Toast</span> <span class="p">{}</span>
<span class="k">var</span> <span class="n">toast</span> <span class="o">=</span> <span class="vg">Toast</span><span class="p">();</span>
<span class="k">print</span> <span class="n">toast</span><span class="p">.</span><span class="n">jam</span> <span class="o">=</span> <span class="s">&quot;grape&quot;</span><span class="p">;</span> <span class="c1">// Prints &quot;grape&quot;.</span>
</pre></div>


<p>Unlike when reading a field, we don&rsquo;t need to worry about the hash table not
containing the field. A setter implicitly creates the field if needed. We do
need to handle the user incorrectly trying to store a field on a value that
isn&rsquo;t an instance:</p>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="k">case</span> <span class="nl">OP_SET_PROPERTY</span><span class="p">:</span> <span class="p">{</span>                         
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_INSTANCE</span><span class="p">(</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span> <span class="p">{</span>                  
          <span class="n">runtimeError</span><span class="p">(</span><span class="s">&quot;Only instances have fields.&quot;</span><span class="p">);</span>
          <span class="k">return</span> <span class="n">INTERPRET_RUNTIME_ERROR</span><span class="p">;</span>             
        <span class="p">}</span>                                             
<br></pre><pre class="insert-after"><span></span>        <span class="n">ObjInstance</span><span class="o">*</span> <span class="n">instance</span> <span class="o">=</span> <span class="n">AS_INSTANCE</span><span class="p">(</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span> 
</pre></div>

<div class="source-file-narrow"><em>vm.c</em>, in <em>run</em>()</div>

<p>Exactly like with get expressions, we check the value&rsquo;s type and report a
runtime error if it&rsquo;s invalid. And, with that, the stateful side of Lox&rsquo;s
support for object-oriented programming is in place. Give it a try:</p>
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="vg">Pair</span> <span class="p">{}</span>

<span class="k">var</span> <span class="n">pair</span> <span class="o">=</span> <span class="vg">Pair</span><span class="p">();</span>
<span class="n">pair</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">pair</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">print</span> <span class="n">pair</span><span class="p">.</span><span class="n">first</span> <span class="o">+</span> <span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="c1">// 3.</span>
</pre></div>


<p>This doesn&rsquo;t really feel very <em>object</em>-oriented. It&rsquo;s more like a strange
dynamically-typed variant of C where objects are loose struct-like bags of data.
Sort of a dynamic procedural language. But this is a big step in expressiveness.
Our Lox implementation now lets users freely aggregate data into bigger units.
In the next chapter, we will breathe life into those inert blobs.</p>
<div class="challenges">
<h2><a href="#challenges" name="challenges">Challenges</a></h2>

<ol>
<li>
<p>Trying to access a non-existent field on an object immediately aborts the
    entire VM. The user has no way to recover from this runtime error, nor is
    there any way to see if a field exists <em>before</em> trying to access it. It&rsquo;s up
    to the user to ensure on their own that only valid fields are read.</p>
<p>How do other dynamically-typed languages handle missing fields? What do you
think Lox should do? Implement your solution.</p>
</li>
<li>
<p>Fields are accessed at runtime by their <em>string</em> name. But that name must
    always appear directly in the source code as an <em>identifier token</em>. A user
    program cannot imperatively build a string value and then use that as the
    name of a field. Do you think they should be able to? Devise a language
    feature that enables that and implement it.</p>
</li>
<li>
<p>Conversely, Lox offers no way to <em>remove</em> a field from an instance. You can
    set a field&rsquo;s value to <code>nil</code>, but the entry in the hash table is still
    there. How do other languages handle this? Choose and implement a strategy
    for Lox.</p>
</li>
<li>
<p>Because fields are accessed by name at runtime, working with instance state
    is slow. It&rsquo;s technically a constant-time operation<span class="em">&mdash;</span>thanks, hash tables<span class="em">&mdash;</span>but the constant factors are relatively large. This is a major component
    of why dynamic languages are slower than statically-typed ones.</p>
<p>How do sophisticated implementations of dynamically-typed languages cope
with and optimize this?</p>
</li>
</ol>
</div>

<footer>
<a href="methods-and-initializers.html" class="next">
  Next Chapter: &ldquo;Methods and Initializers&rdquo; &rarr;
</a>
Hand-crafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2020</a>
</footer>
</article>

</div>
</body>
</html>