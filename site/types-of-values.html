<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<title>Types of Values &middot; Crafting Interpreters</title>

<!-- Tell mobile browsers we're optimized for them and they don't need to crop
     the viewport. -->
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" type="text/css" href="style.css" />

<!-- Oh, God, Source Code Pro is so beautiful it makes me want to cry. -->
<link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600' rel='stylesheet' type='text/css'>
<link rel="icon" type="image/png" href="image/favicon.png" />
<script src="jquery-1.10.1.min.js"></script>
<script src="script.js"></script>

<!-- Google analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42804721-2', 'auto');
  ga('send', 'pageview');
</script>

</head>
<body id="top">

<!-- <div class="scrim"></div> -->
<nav class="wide">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="contents">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">Types of Values<small>18</small></a></h3>

<ul>
    <li><a href="#tagged-unions"><small>18.1</small> tagged unions</a></li>
    <li><a href="#converting-in-and-out-of-values"><small>18.2</small> converting in and out of values</a></li>
    <li><a href="#dynamically-typed-numbers"><small>18.3</small> dynamically-typed numbers</a></li>
    <li><a href="#true-false-and-nil"><small>18.4</small> true, false and nil</a></li>
    <li><a href="#design-note"><small>18.5</small> design note</a></li>
    <li><a href="#high-level-outline"><small>18.6</small> high level outline</a></li>
    <li><a href="#random-notes"><small>18.7</small> random notes</a></li>
</ul>


<div class="prev-next">
    <a href="compiling-expressions.html" title="Compiling Expressions" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="strings.html" title="Strings" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
</nav>

<nav class="narrow">
<a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
<a href="compiling-expressions.html" title="Compiling Expressions" class="prev">←</a>
<a href="strings.html" title="Strings" class="next">→</a>
</nav>

<div class="page">
<div class="nav-wrapper">
<nav class="floating">
  <a href="/"><img src="image/logotype-small.png" title="Crafting Interpreters"></a>
  <div class="expandable">
<!-- If there is a part, it must be a chapter within a part. -->
<h3><a href="#top">Types of Values<small>18</small></a></h3>

<ul>
    <li><a href="#tagged-unions"><small>18.1</small> tagged unions</a></li>
    <li><a href="#converting-in-and-out-of-values"><small>18.2</small> converting in and out of values</a></li>
    <li><a href="#dynamically-typed-numbers"><small>18.3</small> dynamically-typed numbers</a></li>
    <li><a href="#true-false-and-nil"><small>18.4</small> true, false and nil</a></li>
    <li><a href="#design-note"><small>18.5</small> design note</a></li>
    <li><a href="#high-level-outline"><small>18.6</small> high level outline</a></li>
    <li><a href="#random-notes"><small>18.7</small> random notes</a></li>
</ul>


<div class="prev-next">
    <a href="compiling-expressions.html" title="Compiling Expressions" class="left">&larr;&nbsp;Previous</a>
    <a href="a-bytecode-virtual-machine.html" title="A Bytecode Virtual Machine">&uarr;&nbsp;Up</a>
    <a href="strings.html" title="Strings" class="right">Next&nbsp;&rarr;</a>
</div>  </div>
  <a id="expand-nav">≡</a>
</nav>
</div>

<article class="chapter">

  <div class="number">18</div>
  <h1>Types of Values</h1>

<div class="sign-up closable">
    <h1>This book is a work in progress!</h1>
    <span class="dismiss">&times;</span>
    <p>If you see a mistake, find something unclear, or have a suggestion, please <a href="https://github.com/munificent/craftinginterpreters/issues" target="_blank">let me know</a>. To learn when new chapters are up, join the mailing list:</p>

  <!-- Begin MailChimp Signup Form -->
  <div id="mc_embed_signup">
  <form action="//gameprogrammingpatterns.us7.list-manage.com/subscribe/post?u=0952ca43ed2536d6717766b88&amp;id=6e96334109" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
    <input type="email" value="" name="EMAIL" class="email" id="mce-EMAIL" placeholder="Your email address" required>
    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_0952ca43ed2536d6717766b88_6e96334109" tabindex="-1" value=""></div>
    <input type="submit" value="Sign me up!" name="subscribe" id="mc-embedded-subscribe" class="button">
  </form>
  </div>
  <!--End mc_embed_signup-->
  <p class="small">(I post about once a month. Don&#8217;t worry, I won&#8217;t spam you.)</p>
</div>

<ul>
<li>simpler than previous chapters</li>
<li>palette cleanser</li>
<li>
<p>one main concept<span class="em">&mdash;</span>tagged unions</p>
</li>
<li>
<p>lox dynamically typed</p>
</li>
<li>same var can hold bool, num, string, etc. at different points in time</li>
<li>right now, values can only be numbers</li>
<li>
<p>[&ldquo;unityped&rdquo; like forth, bcpl]</p>
</li>
<li>
<p>introduce two new types, bool and nil</p>
</li>
<li>these two easy because fixed size, immutable</li>
<li>other types like strings and obj later</li>
</ul>
<h2><a href="#tagged-unions" name="tagged-unions"><small>18&#8202;.&#8202;1</small> tagged unions</a></h2>
<ul>
<li>build value rep out of raw bits</li>
<li>c gives nothing</li>
<li>at runtime, just undifferentiated array of bytes</li>
<li>
<p>up to us to decide how many bits to use and what they mean</p>
</li>
<li>
<p>two problems to solve rep value</p>
</li>
<li>how does value carry type?<ul>
<li>need to be able to tell at runtime if value is bool, number, etc.</li>
<li>c doesn&rsquo;t, up to us</li>
</ul>
</li>
<li>how do we store value itself?<ul>
<li>different numbers</li>
<li>true versus false</li>
<li>hard because different sizes</li>
<li>need 64 bits for double<ul>
<li>[sort, see opt chapter]</li>
</ul>
</li>
<li>one bit for bool, true/false</li>
<li>no extra bits for null</li>
<li>if have an array of values of mixed type, how big each array element?</li>
</ul>
</li>
<li>
<p>meta problem is doing so efficiently</p>
</li>
<li>
<p>soln is straightforward</p>
</li>
<li>to store type, each value have enum identifying type</li>
</ul>
<div class="codehilite"><pre class="insert-before"><br><span></span><span class="k">typedef</span> <span class="kt">double</span> <span class="n">Value</span><span class="p">;</span>
</pre><div class="source-file"><em>value.h</em></div>
<pre class="insert"><span></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
  <span class="n">VAL_BOOL</span><span class="p">,</span>
  <span class="n">VAL_NIL</span><span class="p">,</span>
  <span class="n">VAL_NUMBER</span><span class="p">,</span>
<span class="p">}</span> <span class="n">ValueType</span><span class="p">;</span>
<br></pre><pre class="insert-after"><br><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</pre></div>

<ul>
<li>then for some types, have additional type for value</li>
<li>could do struct with fields to store bits for each type</li>
</ul>
<p><strong>todo: illustrate struct fields</strong></p>
<ul>
<li>but value has only one type, so other fields would be unused</li>
<li>union</li>
<li>like struct, but fields share same memory</li>
</ul>
<p><strong>todo: illustrate union fields and showing largest dictates size</strong></p>
<ul>
<li>size is size of largest field</li>
<li>since fields reuse same bits, have to be careful know what doing</li>
<li>if store one field then access another, misinterpret bits</li>
<li>[can be useful to do so on purpose]</li>
<li>value is struct wraps two</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span><span class="cp">#include</span> <span class="cpf">&quot;common.h&quot;</span><span class="cp"></span>
<br></pre><div class="source-file"><em>value.h</em><br>
replace 1 line</div>
<pre class="insert"><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">ValueType</span> <span class="n">type</span><span class="p">;</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">boolean</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">number</span><span class="p">;</span>
  <span class="p">}</span> <span class="n">as</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Value</span><span class="p">;</span>
</pre><pre class="insert-after"><br><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</pre></div>

<ul>
<li>field for type enum, called &ldquo;tag&rdquo;</li>
<li>field for data union</li>
<li>call &ldquo;as&rdquo; because accessing field sort of like converting to primitive type</li>
</ul>
<p><strong>todo: illustrate</strong></p>
<ul>
<li>&ldquo;tagged union&rdquo;</li>
<li>on 64-bit, value is 16 bytes</li>
<li>8 for largest union field, double</li>
<li>8 for type tag</li>
<li>only have a few different types, so really wasteful</li>
<li>[could shrink enum but doubles need to be aligned to 8-byte boundary
    so in things like array of value, would pad anyway]</li>
<li>do better later</li>
<li>but good enough for now</li>
<li>small enough can pass around on stack by copying value</li>
<li>safe to do because values immutable</li>
</ul>
<h2><a href="#converting-in-and-out-of-values" name="converting-in-and-out-of-values"><small>18&#8202;.&#8202;2</small> converting in and out of values</a></h2>
<ul>
<li>that&rsquo;s it for value rep, but rest of interp assumes value <em>is</em> double</li>
<li>now value can represent double, but not same as</li>
<li>
<p>call all broken now, need to go through and fix</p>
</li>
<li>
<p>since can&rsquo;t directly cast c double to value, need way to produce or wrap
  raw c data into value</p>
</li>
<li>couple of macros</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span><span class="p">}</span> <span class="n">Value</span><span class="p">;</span>
</pre><div class="source-file"><em>value.h</em><br>
add after <em>Value</em></div>
<pre class="insert"><br><span></span><span class="cp">#define BOOL_VAL(value)   ((Value){ VAL_BOOL, { .boolean = value } })</span>
<span class="cp">#define NIL_VAL           ((Value){ VAL_NIL, { .number = 0 } })</span>
<span class="cp">#define NUMBER_VAL(value) ((Value){ VAL_NUMBER, { .number = value } })</span>
</pre><pre class="insert-after"><br><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</pre></div>

<ul>
<li>take c value of appropriate type and produce Value</li>
<li>set type field and store data field</li>
<li>use c99 struct init</li>
<li>
<p>[in c89 no way to create struct in expr, have to write fn that returns struct]</p>
</li>
<li>
<p>before interp c code can do anything useful with value, need to get raw
  value back out</p>
</li>
<li>more macros</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span><span class="p">}</span> <span class="n">Value</span><span class="p">;</span>
</pre><div class="source-file"><em>value.h</em><br>
add after <em>Value</em></div>
<pre class="insert"><br><span></span><span class="cp">#define AS_BOOL(value)    ((value).as.boolean)</span>
<span class="cp">#define AS_NUMBER(value)  ((value).as.number)</span>
</pre><pre class="insert-after"><br><span></span><span class="cp">#define BOOL_VAL(value)   ((Value){ VAL_BOOL, { .boolean = value } })</span>
</pre></div>

<ul>
<li>macros directly access union field</li>
<li>if call AS_NUMBER() on value was created from, say, BOOL_VAL(), get weird
  bits back</li>
<li>
<p>not safe</p>
</li>
<li>
<p>need to check that value has type first</p>
</li>
<li>core of dynamic typing</li>
<li>[in static lang, know what type is at compile time so can directly access
  bits as type. type system is math proof that doing so is safe]</li>
<li>couple more macros</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span><span class="p">}</span> <span class="n">Value</span><span class="p">;</span>
</pre><div class="source-file"><em>value.h</em><br>
add after <em>Value</em></div>
<pre class="insert"><br><span></span><span class="cp">#define IS_BOOL(value)    ((value).type == VAL_BOOL)</span>
<span class="cp">#define IS_NIL(value)     ((value).type == VAL_NIL)</span>
<span class="cp">#define IS_NUMBER(value)  ((value).type == VAL_NUMBER)</span>
</pre><pre class="insert-after"><br><span></span><span class="cp">#define AS_BOOL(value)    ((value).as.boolean)</span>
</pre></div>

<ul>
<li>these sets of macros let us safely move between lox dynamic world and c
  static world</li>
</ul>
<h2><a href="#dynamically-typed-numbers" name="dynamically-typed-numbers"><small>18&#8202;.&#8202;3</small> dynamically-typed numbers</a></h2>
<ul>
<li>have value rep, have tools, fix existing lox to use new value rep</li>
<li>
<p>kind of grind, just blowing through code</p>
</li>
<li>
<p>start at beginning</p>
</li>
<li>first values created as constants in compiler</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">strtod</span><span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">previous</span><span class="p">.</span><span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>number</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>  <span class="n">emitConstant</span><span class="p">(</span><span class="n">NUMBER_VAL</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
</pre><pre class="insert-after"><span></span><span class="p">}</span>
</pre></div>

<ul>
<li>
<p>after converting lexeme to c double, convert to value</p>
</li>
<li>
<p>over in runtime</p>
</li>
<li>print statement uses this fn to output value to stdout</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span><span class="kt">void</span> <span class="nf">printValue</span><span class="p">(</span><span class="n">Value</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</pre><div class="source-file"><em>value.c</em><br>
in <em>printValue</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>  <span class="k">switch</span> <span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">VAL_BOOL</span><span class="p">:</span>   <span class="n">printf</span><span class="p">(</span><span class="n">AS_BOOL</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;true&quot;</span> <span class="o">:</span> <span class="s">&quot;false&quot;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">VAL_NIL</span><span class="p">:</span>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;nil&quot;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">VAL_NUMBER</span><span class="p">:</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%g&quot;</span><span class="p">,</span> <span class="n">AS_NUMBER</span><span class="p">(</span><span class="n">value</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
</pre><pre class="insert-after"><span></span><span class="p">}</span>
</pre></div>

<ul>
<li>delete old code assumed value was double</li>
<li>now have few different types to handle</li>
<li>cases for each type</li>
<li>
<p>inside each case, unwrap now that we know type</p>
</li>
<li>
<p>next simplest operation is unary negate</p>
</li>
<li>
<p>pops number off stack, negates, pushes result</p>
</li>
<li>
<p>now have to worry about value type</p>
</li>
<li>what if user does</li>
</ul>
<div class="codehilite"><pre><span></span><span class="k">print</span> <span class="o">-</span><span class="nb">false</span><span class="p">;</span> <span class="c1">// Uh...</span>
</pre></div>


<ul>
<li>have entered realm of runtime errors</li>
<li>before performing an op that requires certain type, have to check that
  value has that type</li>
<li>[major source of perf diff between dynamic and static lang]</li>
<li>for negate:</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="k">case</span> <span class="nl">OP_DIVIDE</span><span class="p">:</span>   <span class="n">BINARY_OP</span><span class="p">(</span><span class="o">/</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 1 line</div>
<pre class="insert"><span></span>      <span class="k">case</span> <span class="nl">OP_NEGATE</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_NUMBER</span><span class="p">(</span><span class="n">peek</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span> <span class="p">{</span>
          <span class="n">runtimeError</span><span class="p">(</span><span class="s">&quot;Operand must be a number.&quot;</span><span class="p">);</span>
          <span class="k">return</span> <span class="n">INTERPRET_RUNTIME_ERROR</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">push</span><span class="p">(</span><span class="n">NUMBER_VAL</span><span class="p">(</span><span class="o">-</span><span class="n">AS_NUMBER</span><span class="p">(</span><span class="n">pop</span><span class="p">())));</span>
        <span class="k">break</span><span class="p">;</span>
</pre><pre class="insert-after"><span></span>      <span class="k">case</span> <span class="nl">OP_RETURN</span><span class="p">:</span> <span class="p">{</span>
</pre></div>

<ul>
<li>check to see if value on top of stack is num</li>
<li>if not, report runtime error and bail</li>
<li>
<p>[lox primitive error handling, no exceptions, etc.]</p>
</li>
<li>
<p>only after validate number can we unwrap value, negate, rewrap and push</p>
</li>
<li>
<p>to check value, use</p>
</li>
</ul>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>pop</em>()</div>
<pre><span></span><span class="k">static</span> <span class="n">Value</span> <span class="nf">peek</span><span class="p">(</span><span class="kt">int</span> <span class="n">distance</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">vm</span><span class="p">.</span><span class="n">stackTop</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">distance</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>

<ul>
<li>returns value on stack but doesn&rsquo;t pop</li>
<li>[why not just pop? could here. in later chapters will be important to leave
  stuff as long as possible so that if gc happens in middle of op, value
  doesn&rsquo;t accidentally get collected]</li>
<li>arg is how far down the stack</li>
<li>
<p>zero is top, 1 is one down from stack, etc.</p>
</li>
<li>
<p>to report runtime error</p>
</li>
</ul>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>resetStack</em>()</div>
<pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">runtimeError</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">format</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
  <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
  <span class="n">vfprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
  <span class="n">fputs</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>

  <span class="kt">size_t</span> <span class="n">instruction</span> <span class="o">=</span> <span class="n">vm</span><span class="p">.</span><span class="n">ip</span> <span class="o">-</span> <span class="n">vm</span><span class="p">.</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">code</span><span class="p">;</span>
  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;[line %d] in script</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">vm</span><span class="p">.</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">lines</span><span class="p">[</span><span class="n">instruction</span><span class="p">]);</span>

  <span class="n">resetStack</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<ul>
<li>used variadic fns often in c, like printf</li>
<li>if never defined one before, this what it looks like</li>
<li>va_list stuff is weird little api for accessing variadic args</li>
<li>won&rsquo;t go into detail here</li>
<li>
<p>just used to forward runtimeError() var args to vfprint(), which is
  version of printf() that takes explicit va_list for args</p>
</li>
<li>
<p>later will want to generated formatted runtime error messages with parameters</p>
</li>
<li>
<p>lets us do that</p>
</li>
<li>
<p>after show hopefully helpful error message, tell user where in program error
  occurred</p>
</li>
<li>similar to reporting compile error</li>
<li>compiler uses line info in token</li>
<li>passes that line info in when generating chunk</li>
<li>now read that back out of chunk</li>
<li>get line at current bytecode instruction offset</li>
<li>should be line user&rsquo;s prog that bytecode was generated from</li>
<li>
<p>[better would be to show full stack trace, but don&rsquo;t have fns yet, so don&rsquo;t
  even have stack]</p>
</li>
<li>
<p>need to include va_list stuff</p>
</li>
</ul>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add to top of file</div>
<pre class="insert"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdarg.h&gt;</span><span class="cp"></span>
</pre><pre class="insert-after"><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
</pre></div>

<h3><a href="#binary-arithmetic-operators" name="binary-arithmetic-operators"><small>18&#8202;.&#8202;3&#8202;.&#8202;1</small> binary arithmetic operators</a></h3>
<ul>
<li>that&rsquo;s unary, binary little more of a production</li>
<li>have four binary ops that different only in underlying c op: +, -, *, /</li>
<li>to reduce copy/paste, defined macro to reuse code for all four</li>
<li>really useful now because replace that macro to do runtime checking and
  covers all four:</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span><span class="cp">#define READ_CONSTANT() (vm.chunk-&gt;constants.values[READ_BYTE()])</span>
<br></pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 6 lines</div>
<pre class="insert"><span></span><span class="cp">#define BINARY_OP(valueType, op) \</span>
<span class="cp">    do { \</span>
<span class="cp">      if (!IS_NUMBER(peek(0)) || !IS_NUMBER(peek(1))) { \</span>
<span class="cp">        runtimeError(&quot;Operands must be numbers.&quot;); \</span>
<span class="cp">        return INTERPRET_RUNTIME_ERROR; \</span>
<span class="cp">      } \</span>
<span class="cp">      \</span>
<span class="cp">      double b = AS_NUMBER(pop()); \</span>
<span class="cp">      double a = AS_NUMBER(pop()); \</span>
<span class="cp">      push(valueType(a op b)); \</span>
<span class="cp">    } while (false)</span>
</pre><pre class="insert-after"><br><span></span>  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</pre></div>

<ul>
<li>similar to unary</li>
<li>first check that operands are both numbers</li>
<li>runtime error if not</li>
<li>if ok, pop, unwrap, perform op, and push</li>
<li>to wrap value back, use <code>valueType</code> param passed to macro</li>
<li>let&rsquo;s use macro for binary operators where result is any type</li>
<li>for arith, result is num, so pass in <code>NUMBER_VAL</code>:</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="p">}</span>
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()<br>
replace 4 lines</div>
<pre class="insert"><span></span>      <span class="k">case</span> <span class="nl">OP_ADD</span><span class="p">:</span>      <span class="n">BINARY_OP</span><span class="p">(</span><span class="n">NUMBER_VAL</span><span class="p">,</span> <span class="o">+</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="nl">OP_SUBTRACT</span><span class="p">:</span> <span class="n">BINARY_OP</span><span class="p">(</span><span class="n">NUMBER_VAL</span><span class="p">,</span> <span class="o">-</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="nl">OP_MULTIPLY</span><span class="p">:</span> <span class="n">BINARY_OP</span><span class="p">(</span><span class="n">NUMBER_VAL</span><span class="p">,</span> <span class="o">*</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="nl">OP_DIVIDE</span><span class="p">:</span>   <span class="n">BINARY_OP</span><span class="p">(</span><span class="n">NUMBER_VAL</span><span class="p">,</span> <span class="o">/</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</pre><pre class="insert-after"><span></span>      <span class="k">case</span> <span class="nl">OP_NEGATE</span><span class="p">:</span>
</pre></div>

<ul>
<li>for comparison, like &gt;, takes num but returns bool, so will use <code>BOOL_VAL</code></li>
</ul>
<h2><a href="#true-false-and-nil" name="true-false-and-nil"><small>18&#8202;.&#8202;4</small> true, false and nil</a></h2>
<ul>
<li>existing code all works now</li>
<li>clox is basically less efficient unityped lang</li>
<li>can internally rep other types, but no way to produce</li>
<li>now flesh out by adding bool and nil literals, and operators on them</li>
</ul>
<hr />
<ul>
<li>start with literals</li>
<li>simple, so do all at once</li>
<li>with numbers, many different values, so number literals go into constant
  table and have instr to load them</li>
<li>could do same thing for bool and nil</li>
<li>just store, say <code>true</code> in const table and load from there</li>
<li>reuse existing <code>OP_CONST</code></li>
<li>but given only three magic vals, overkill to have two-byte instr and const
  table entry</li>
<li>[many bytecode instr sets have dedicated op codes from small number values]</li>
<li>instead, define ops for true, false, nil that push respective values directly</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="n">OP_CONSTANT</span><span class="p">,</span>
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert"><span></span>  <span class="n">OP_NIL</span><span class="p">,</span>
  <span class="n">OP_TRUE</span><span class="p">,</span>
  <span class="n">OP_FALSE</span><span class="p">,</span>
</pre><pre class="insert-after"><span></span>  <span class="n">OP_ADD</span><span class="p">,</span>
</pre></div>

<ul>
<li>
<p>scanner already handles as keywords, so to parse,
  slot parser fn into pratt parser table at appropriate token</p>
</li>
<li>
<p>three token types, use same fn for all three</p>
</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_ELSE</span>
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert"><span></span>  <span class="p">{</span> <span class="n">literal</span><span class="p">,</span>  <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_FALSE</span>
</pre><pre class="insert-after"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_FUN</span>
</pre></div>

<p>&hellip;</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_THIS</span>
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert"><span></span>  <span class="p">{</span> <span class="n">literal</span><span class="p">,</span>  <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_TRUE</span>
</pre><pre class="insert-after"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_VAR</span>
</pre></div>

<p>&hellip;</p>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_IF</span>
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert"><span></span>  <span class="p">{</span> <span class="n">literal</span><span class="p">,</span>  <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_NIL</span>
</pre><pre class="insert-after"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_OR</span> <span class="p">},</span>         <span class="c1">// TOKEN_OR</span>
</pre></div>

<ul>
<li>when encounter <code>false</code>, <code>nil</code> or <code>true</code> in prefix position, all call</li>
</ul>
<div class="codehilite"><div class="source-file"><em>compiler.c</em><br>
add after <em>binary</em>()</div>
<pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">literal</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">previous</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">TOKEN_FALSE</span><span class="p">:</span> <span class="n">emitByte</span><span class="p">(</span><span class="n">OP_FALSE</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">TOKEN_NIL</span><span class="p">:</span> <span class="n">emitByte</span><span class="p">(</span><span class="n">OP_NIL</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">TOKEN_TRUE</span><span class="p">:</span> <span class="n">emitByte</span><span class="p">(</span><span class="n">OP_TRUE</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// Unreachable.</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<ul>
<li>keyword token already consumed, so only need to output instr</li>
<li>look at token type to see which literal</li>
<li>[could have defined separate parser fns for each too]</li>
<li>front end can now compile <code>true</code>, <code>false</code>, and <code>nil</code>, in user prog</li>
<li>now vm need to interp</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="k">case</span> <span class="nl">OP_CONSTANT</span><span class="p">:</span> <span class="p">{</span>
        <span class="n">Value</span> <span class="n">constant</span> <span class="o">=</span> <span class="n">READ_CONSTANT</span><span class="p">();</span>
        <span class="n">push</span><span class="p">(</span><span class="n">constant</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span></span>      <span class="k">case</span> <span class="nl">OP_NIL</span><span class="p">:</span> <span class="n">push</span><span class="p">(</span><span class="n">NIL_VAL</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="nl">OP_TRUE</span><span class="p">:</span> <span class="n">push</span><span class="p">(</span><span class="n">BOOL_VAL</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="nl">OP_FALSE</span><span class="p">:</span> <span class="n">push</span><span class="p">(</span><span class="n">BOOL_VAL</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
</pre><pre class="insert-after"><span></span>      <span class="k">case</span> <span class="nl">OP_ADD</span><span class="p">:</span>      <span class="n">BINARY_OP</span><span class="p">(</span><span class="n">NUMBER_VAL</span><span class="p">,</span> <span class="o">+</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</pre></div>

<ul>
<li>self-explanatory</li>
<li>also want to keep dis complete</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="k">case</span> <span class="nl">OP_CONSTANT</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">constantInstruction</span><span class="p">(</span><span class="s">&quot;OP_CONSTANT&quot;</span><span class="p">,</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">OP_NIL</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">simpleInstruction</span><span class="p">(</span><span class="s">&quot;OP_NIL&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
    <span class="k">case</span> <span class="nl">OP_TRUE</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">simpleInstruction</span><span class="p">(</span><span class="s">&quot;OP_TRUE&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
    <span class="k">case</span> <span class="nl">OP_FALSE</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">simpleInstruction</span><span class="p">(</span><span class="s">&quot;OP_FALSE&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">OP_ADD</span><span class="p">:</span>
</pre></div>

<ul>
<li>have literals for new types now, but can&rsquo;t do anything with them</li>
<li>nil won&rsquo;t be very useful yet, but can at least start adding boolean ops</li>
</ul>
<h3><a href="#logical-not-and-falsiness" name="logical-not-and-falsiness"><small>18&#8202;.&#8202;4&#8202;.&#8202;1</small> logical not and falsiness</a></h3>
<ul>
<li>simplest logical op is unary not, <code>!</code></li>
</ul>
<div class="codehilite"><pre><span></span><span class="k">print</span> <span class="o">!</span><span class="nb">true</span><span class="p">;</span> <span class="c1">// &quot;false&quot;</span>
</pre></div>


<ul>
<li>add new instr for operation</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="n">OP_DIVIDE</span><span class="p">,</span>
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert"><span></span>  <span class="n">OP_NOT</span><span class="p">,</span>
</pre><pre class="insert-after"><span></span>  <span class="n">OP_NEGATE</span><span class="p">,</span>
</pre></div>

<ul>
<li>to parse, can use existing unary parser fn wrote for <code>-</code></li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="n">binary</span><span class="p">,</span>  <span class="n">PREC_FACTOR</span> <span class="p">},</span>     <span class="c1">// TOKEN_STAR</span>
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert"><span></span>  <span class="p">{</span> <span class="n">unary</span><span class="p">,</span>    <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_BANG</span>
</pre><pre class="insert-after"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_EQUALITY</span> <span class="p">},</span>   <span class="c1">// TOKEN_BANG_EQUAL</span>
</pre></div>

<ul>
<li>that fn already has switch on oper token type to decide what op to write</li>
<li>switch only had one case before, now add another</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="k">switch</span> <span class="p">(</span><span class="n">operatorType</span><span class="p">)</span> <span class="p">{</span>
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>unary</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">TOKEN_BANG</span><span class="p">:</span> <span class="n">emitByte</span><span class="p">(</span><span class="n">OP_NOT</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">TOKEN_MINUS</span><span class="p">:</span> <span class="n">emitByte</span><span class="p">(</span><span class="n">OP_NEGATE</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// Unreachable.</span>
  <span class="p">}</span>
</pre></div>

<ul>
<li>what does it do?</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="k">case</span> <span class="nl">OP_DIVIDE</span><span class="p">:</span>   <span class="n">BINARY_OP</span><span class="p">(</span><span class="n">NUMBER_VAL</span><span class="p">,</span> <span class="o">/</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span></span>      <span class="k">case</span> <span class="nl">OP_NOT</span><span class="p">:</span>
        <span class="n">push</span><span class="p">(</span><span class="n">BOOL_VAL</span><span class="p">(</span><span class="n">isFalsey</span><span class="p">(</span><span class="n">pop</span><span class="p">())));</span>
        <span class="k">break</span><span class="p">;</span>
</pre><pre class="insert-after"><span></span>      <span class="k">case</span> <span class="nl">OP_NEGATE</span><span class="p">:</span>
</pre></div>

<ul>
<li>like other unary, pops operand, performs op, pushes result</li>
<li>as usual, have to worry about different types</li>
<li>can do:</li>
</ul>
<div class="codehilite"><pre><span></span><span class="k">print</span> <span class="o">!</span><span class="nb">nil</span><span class="p">;</span>
</pre></div>


<ul>
<li>rule for how different types when used in Boolean context called &ldquo;falsiness&rdquo;</li>
<li>implement in fn</li>
</ul>
<div class="codehilite"><div class="source-file"><em>vm.c</em><br>
add after <em>peek</em>()</div>
<pre><span></span><span class="k">static</span> <span class="kt">bool</span> <span class="nf">isFalsey</span><span class="p">(</span><span class="n">Value</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">IS_NIL</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">IS_BOOL</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">AS_BOOL</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>

<ul>
<li>
<p>back when first defined lox, somewhat arbitrarily said <code>nil</code> and <code>false</code>
  falsey, everything else true</p>
</li>
<li>
<p>new op, so new dis</p>
</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="k">case</span> <span class="nl">OP_DIVIDE</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">simpleInstruction</span><span class="p">(</span><span class="s">&quot;OP_DIVIDE&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">OP_NOT</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">simpleInstruction</span><span class="p">(</span><span class="s">&quot;OP_NOT&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">OP_NEGATE</span><span class="p">:</span>
</pre></div>

<h3><a href="#comparison" name="comparison"><small>18&#8202;.&#8202;4&#8202;.&#8202;2</small> comparison</a></h3>
<ul>
<li>have enough in place to do comparison operators too</li>
<li>equality, inequality, and &lt; &gt;</li>
<li>even though latter take numbers, couldn&rsquo;t do in last chapter because result
  isn&rsquo;t number</li>
<li>now can</li>
<li>
<p>[still can&rsquo;t do logic <code>||</code> and <code>&amp;&amp;</code>. need control flow for that. later]</p>
</li>
<li>
<p>six operators, here&rsquo;s new ops</p>
</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="n">OP_FALSE</span><span class="p">,</span>
</pre><div class="source-file"><em>chunk.h</em><br>
in enum <em>OpCode</em></div>
<pre class="insert"><span></span>  <span class="n">OP_EQUAL</span><span class="p">,</span>
  <span class="n">OP_GREATER</span><span class="p">,</span>
  <span class="n">OP_LESS</span><span class="p">,</span>
</pre><pre class="insert-after"><span></span>  <span class="n">OP_ADD</span><span class="p">,</span>
</pre></div>

<ul>
<li>only three?</li>
<li>what about <code>!=</code>? <code>&lt;=</code>? <code>&gt;=</code>?</li>
<li>could create ops for each</li>
<li>honestly, would be faster, so <em>should</em> do this in real interp</li>
<li>book about teaching</li>
<li>want to get you thinking that bytecode doesn&rsquo;t have to closely follow
  source</li>
<li><code>a != b</code> is same as <code>!(a == b)</code>, so can implement <code>!=</code> using <code>OP_EQUAL</code>
  followed by <code>OP_NOT</code></li>
<li>same for <code>a &lt;= b</code> -&gt; <code>!(a &gt; b)</code></li>
<li>
<p><code>a &gt;= b</code> -&gt; <code>!(a &lt; b)</code></p>
</li>
<li>
<p>all six operators use existing binary parser fn</p>
</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="p">{</span> <span class="n">unary</span><span class="p">,</span>    <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_BANG</span>
</pre><div class="source-file"><em>compiler.c</em><br>
replace 1 line</div>
<pre class="insert"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="n">binary</span><span class="p">,</span>  <span class="n">PREC_EQUALITY</span> <span class="p">},</span>   <span class="c1">// TOKEN_BANG_EQUAL</span>
</pre><pre class="insert-after"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_EQUAL</span>
</pre></div>

<ul>
<li>inside binary, switch to output instrs gets new cases</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_EQUAL</span>
</pre><div class="source-file"><em>compiler.c</em><br>
replace 5 lines</div>
<pre class="insert"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="n">binary</span><span class="p">,</span>  <span class="n">PREC_EQUALITY</span> <span class="p">},</span>   <span class="c1">// TOKEN_EQUAL_EQUAL</span>
  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="n">binary</span><span class="p">,</span>  <span class="n">PREC_COMPARISON</span> <span class="p">},</span> <span class="c1">// TOKEN_GREATER</span>
  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="n">binary</span><span class="p">,</span>  <span class="n">PREC_COMPARISON</span> <span class="p">},</span> <span class="c1">// TOKEN_GREATER_EQUAL</span>
  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="n">binary</span><span class="p">,</span>  <span class="n">PREC_COMPARISON</span> <span class="p">},</span> <span class="c1">// TOKEN_LESS</span>
  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="n">binary</span><span class="p">,</span>  <span class="n">PREC_COMPARISON</span> <span class="p">},</span> <span class="c1">// TOKEN_LESS_EQUAL</span>
</pre><pre class="insert-after"><span></span>  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span>     <span class="nb">NULL</span><span class="p">,</span>    <span class="n">PREC_NONE</span> <span class="p">},</span>       <span class="c1">// TOKEN_IDENTIFIER</span>
</pre></div>

<ul>
<li>for <code>==</code>, <code>&lt;</code>, and <code>&gt;</code> output single op</li>
<li>for others, do pair of instrs</li>
<li>first do opposite op, then <code>OP_NOT</code></li>
<li>
<p>latter pops result of former, negates, pushes result</p>
</li>
<li>
<p>six operators for the price of three instrs</p>
</li>
<li>so in vm, only need to implement three</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>  <span class="k">switch</span> <span class="p">(</span><span class="n">operatorType</span><span class="p">)</span> <span class="p">{</span>
</pre><div class="source-file"><em>compiler.c</em><br>
in <em>binary</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">TOKEN_BANG_EQUAL</span><span class="p">:</span>    <span class="n">emitBytes</span><span class="p">(</span><span class="n">OP_EQUAL</span><span class="p">,</span> <span class="n">OP_NOT</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">TOKEN_EQUAL_EQUAL</span><span class="p">:</span>   <span class="n">emitByte</span><span class="p">(</span><span class="n">OP_EQUAL</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">TOKEN_GREATER</span><span class="p">:</span>       <span class="n">emitByte</span><span class="p">(</span><span class="n">OP_GREATER</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">TOKEN_GREATER_EQUAL</span><span class="p">:</span> <span class="n">emitBytes</span><span class="p">(</span><span class="n">OP_LESS</span><span class="p">,</span> <span class="n">OP_NOT</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">TOKEN_LESS</span><span class="p">:</span>          <span class="n">emitByte</span><span class="p">(</span><span class="n">OP_LESS</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">TOKEN_LESS_EQUAL</span><span class="p">:</span>    <span class="n">emitBytes</span><span class="p">(</span><span class="n">OP_GREATER</span><span class="p">,</span> <span class="n">OP_NOT</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">TOKEN_PLUS</span><span class="p">:</span>          <span class="n">emitByte</span><span class="p">(</span><span class="n">OP_ADD</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</pre></div>

<ul>
<li>equality is most general</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>      <span class="k">case</span> <span class="nl">OP_FALSE</span><span class="p">:</span> <span class="n">push</span><span class="p">(</span><span class="n">BOOL_VAL</span><span class="p">(</span><span class="nb">false</span><span class="p">));</span> <span class="k">break</span><span class="p">;</span>
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><br><span></span>      <span class="k">case</span> <span class="nl">OP_EQUAL</span><span class="p">:</span> <span class="p">{</span>
        <span class="n">Value</span> <span class="n">b</span> <span class="o">=</span> <span class="n">pop</span><span class="p">();</span>
        <span class="n">Value</span> <span class="n">a</span> <span class="o">=</span> <span class="n">pop</span><span class="p">();</span>
        <span class="n">push</span><span class="p">(</span><span class="n">BOOL_VAL</span><span class="p">(</span><span class="n">valuesEqual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)));</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
<br></pre><pre class="insert-after"><span></span>      <span class="k">case</span> <span class="nl">OP_ADD</span><span class="p">:</span>      <span class="n">BINARY_OP</span><span class="p">(</span><span class="n">NUMBER_VAL</span><span class="p">,</span> <span class="o">+</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</pre></div>

<ul>
<li>any two value of any type can be compared for equality</li>
<li>equality logic defined in separate fn</li>
<li>fn result always c bool, so can safely wrap in value and push result</li>
<li>fn related to values, so defined over in value module</li>
<li>declare in header</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span><span class="p">}</span> <span class="n">ValueArray</span><span class="p">;</span>
<br></pre><div class="source-file"><em>value.h</em><br>
add after <em>ValueArray</em></div>
<pre class="insert"><span></span><span class="kt">bool</span> <span class="nf">valuesEqual</span><span class="p">(</span><span class="n">Value</span> <span class="n">a</span><span class="p">,</span> <span class="n">Value</span> <span class="n">b</span><span class="p">);</span>
</pre><pre class="insert-after"><span></span><span class="kt">void</span> <span class="nf">initValueArray</span><span class="p">(</span><span class="n">ValueArray</span><span class="o">*</span> <span class="n">array</span><span class="p">);</span>
</pre></div>

<ul>
<li>then implement</li>
</ul>
<div class="codehilite"><div class="source-file"><em>value.c</em><br>
add after <em>printValue</em>()</div>
<pre><span></span><span class="kt">bool</span> <span class="nf">valuesEqual</span><span class="p">(</span><span class="n">Value</span> <span class="n">a</span><span class="p">,</span> <span class="n">Value</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">b</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">VAL_BOOL</span><span class="p">:</span>   <span class="k">return</span> <span class="n">AS_BOOL</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">AS_BOOL</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="k">case</span> <span class="nl">VAL_NIL</span><span class="p">:</span>    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">VAL_NUMBER</span><span class="p">:</span> <span class="k">return</span> <span class="n">AS_NUMBER</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">AS_NUMBER</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<ul>
<li>if values have different types, definitely not equal</li>
<li>[no weird implicit conversions like js or php. no <code>0</code> is not same as <code>"0"</code>]</li>
<li>otherwise, unwrap pair of values and compare directly</li>
<li>[why not just memcmp entire value struct? contains padding and unused bits
  when union uses smaller case like bool or nil. c does not guarantee what&rsquo;s in
  there. could have, say, two <code>nil</code> values with different unused bits in there
  would end up unequal.]</li>
<li>
<p>have to be safe</p>
</li>
<li>
<p>this fn will grow more cases as add other kinds of values<span class="em">&mdash;</span>strings, fns, objs, etc.</p>
</li>
<li>
<p>comparison ops easier</p>
</li>
</ul>
<div class="codehilite"><pre class="insert-before"><br><span></span>
</pre><div class="source-file"><em>vm.c</em><br>
in <em>run</em>()</div>
<pre class="insert"><span></span>      <span class="k">case</span> <span class="nl">OP_GREATER</span><span class="p">:</span>  <span class="n">BINARY_OP</span><span class="p">(</span><span class="n">BOOL_VAL</span><span class="p">,</span> <span class="o">&gt;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="nl">OP_LESS</span><span class="p">:</span>     <span class="n">BINARY_OP</span><span class="p">(</span><span class="n">BOOL_VAL</span><span class="p">,</span> <span class="o">&lt;</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</pre><pre class="insert-after"><span></span>      <span class="k">case</span> <span class="nl">OP_ADD</span><span class="p">:</span>      <span class="n">BINARY_OP</span><span class="p">(</span><span class="n">NUMBER_VAL</span><span class="p">,</span> <span class="o">+</span><span class="p">);</span> <span class="k">break</span><span class="p">;</span>
</pre></div>

<ul>
<li>already extended macro to handle binary ops that return other type</li>
<li>
<p>can reuse here with correct c operator and <code>BOOL_VAL</code> to indicate result
  value type is bool</p>
</li>
<li>
<p>last is dis</p>
</li>
</ul>
<div class="codehilite"><pre class="insert-before"><span></span>    <span class="k">case</span> <span class="nl">OP_FALSE</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">simpleInstruction</span><span class="p">(</span><span class="s">&quot;OP_FALSE&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre><div class="source-file"><em>debug.c</em><br>
in <em>disassembleInstruction</em>()</div>
<pre class="insert"><span></span>    <span class="k">case</span> <span class="nl">OP_EQUAL</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">simpleInstruction</span><span class="p">(</span><span class="s">&quot;OP_EQUAL&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
    <span class="k">case</span> <span class="nl">OP_GREATER</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">simpleInstruction</span><span class="p">(</span><span class="s">&quot;OP_GREATER&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
    <span class="k">case</span> <span class="nl">OP_LESS</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">simpleInstruction</span><span class="p">(</span><span class="s">&quot;OP_LESS&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre><pre class="insert-after"><span></span>    <span class="k">case</span> <span class="nl">OP_ADD</span><span class="p">:</span>
</pre></div>

<ul>
<li>numeric calculator growing to general expression evaluator</li>
<li>can do</li>
</ul>
<div class="codehilite"><pre><span></span><span class="o">!</span><span class="p">(</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">==</span> <span class="o">!</span><span class="nb">nil</span><span class="p">)</span>
</pre></div>


<h2><a href="#design-note" name="design-note"><small>18&#8202;.&#8202;5</small> design note</a></h2>
<p><strong>todo: move to previous chapter?</strong></p>
<ul>
<li>
<p>commodity parsing</p>
</li>
<li>
<p>maybe unpopular opinion</p>
</li>
<li>
<p>won&rsquo;t water down but ok if you disagree</p>
</li>
<li>
<p>people, especially academ got really into parsing and parser theory</p>
</li>
<li>as branch of math produces interesting results</li>
<li>fp folks got really into parser combinators</li>
<li>compiler folks got really into parser generators</li>
<li>
<p>(given any problem, compiler hacker will always solve it by creating a
    new compiler, even when problem is &ldquo;how do i create compiler?&rdquo;)</p>
</li>
<li>
<p>don&rsquo;t want to denigrate that work</p>
</li>
<li>all really interesting</li>
<li>touches on other fun areas of math and cs</li>
<li>really important that have proofs of memory and time bounds of typical parsing
  techniques</li>
<li>
<p>want guarantee that front end won&rsquo;t go exponential</p>
</li>
<li>
<p>parsing does matter</p>
</li>
<li>
<p>but if goal is just to implement lang, don&rsquo;t need to be into it</p>
</li>
<li>pick technique you like and be done with it</li>
<li>recursive descent, pratt, combinator, antlr</li>
<li>whatever you like, pick one and be done with it</li>
<li>will be commodity part of impl, not strategic advantage</li>
<li>
<p>[unless doing something interesting like user-extensible syntax]</p>
</li>
<li>
<p>lisp shows can have successful that barely even has parser and forces user to
  write ast</p>
</li>
<li>
<p>instead of spending four hours researching some crazy memoizing GLR algorithm or something, spend that tweaking the error syntax messages in your parser to be more actionable</p>
</li>
<li>users will thank you</li>
<li>honestly, &gt; half of time hacking on parser should be error messages and error
  recovery</li>
<li>that&rsquo;s where real value prop is</li>
</ul>
<hr />
<h2><a href="#high-level-outline" name="high-level-outline"><small>18&#8202;.&#8202;6</small> high level outline</a></h2>
<ul>
<li>tagged union</li>
<li>fix existing stuff</li>
<li>AS_NUMBER() in compiler</li>
<li>arithmetic operations</li>
<li>runtime errors</li>
<li>falsiness</li>
<li>not operator</li>
<li>comparison operators</li>
<li>bool and nil literals</li>
</ul>
<h2><a href="#random-notes" name="random-notes"><small>18&#8202;.&#8202;7</small> random notes</a></h2>
<ul>
<li>can&rsquo;t just compare bytes of value</li>
<li>c doesn&rsquo;t guarantee initialization of padding bits</li>
</ul>

<footer>
<a href="strings.html" class="next">
  Next Chapter: &ldquo;Strings&rdquo; &rarr;
</a>
Hand-crafted by Robert Nystrom&ensp;&mdash;&ensp;<a href="https://github.com/munificent/craftinginterpreters/blob/master/LICENSE" target="_blank">&copy; 2015&hairsp;&ndash;&hairsp;2018</a>
</footer>
</article>

</div>
</body>
</html>