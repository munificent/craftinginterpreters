There's nothing super algorithmically interesting about the change. We basically
turn it into a dynamic array like we've seen before. A side effect of this
change is that `stackTop` becomes `stackCount`, an int. Using a raw pointer to
the top makes it a little harder to tell if we've run out of capacity:

```c
typedef struct {
  Chunk* chunk;
  uint8_t* ip;
  Value* stack;
  int stackCount;
  int stackCapacity;
} VM;
```

When we first create the VM, we need to initialize the dynamic array fields:

```c
void initVM() {
  vm.stack = NULL;
  vm.stackCapacity = 0;
  resetStack();
}
```

Resetting is still pretty simple:

```c
static void resetStack() {
  vm.stackCount = 0;
}

So is `pop()`:

```c
Value pop() {
  vm.stackCount--;
  return vm.stack[vm.stackCount];
}
```

Where it gets interesting is `push()`:

```c
void push(Value value) {
  if (vm.stackCapacity < vm.stackCount + 1) {
    int oldCapacity = vm.stackCapacity;
    vm.stackCapacity = GROW_CAPACITY(oldCapacity);
    vm.stack = GROW_ARRAY(vm.stack, Value,
                          oldCapacity, vm.stackCapacity);
  }

  vm.stack[vm.stackCount] = value;
  vm.stackCount++;
}
```

That `if` test needs to happen every single time we push a value. That happens
all the time while the VM is running, so this is a significant performance
problem.

We wouldn't want to have to do that. Fortunately, it turns out we won't need
to. If you're willing to limit the generated bytecode to fit within certain
constraints -- which happen to be implicitly true in a language with structured
control flow like Lox -- then you can *statically* determine the maximum amount
of stack space a chunk of bytecode could ever use.

During compilation, you always know how many stack slots are in use for locals
and temporaries at any point in time. So you just keep a running tally of the
highwater mark -- the greatest amount of stack space used at any point, and then
store that in with the resulting chunk.

So instead of checking on every single push, we check once before evaluating
the bytecode to see if the stack is big enough to cover the worst case.
